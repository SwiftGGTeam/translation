title: "objc_msgSend 的新原型"
date: 
tags: [Objective-C,iOS]
categories: [Mike Ash]
permalink: objc_msgsends-new-prototype
keywords: objective-c, objc_msgSend, runtime
custom_title: "objc_msgSend 的新原型"

------

原文链接=https://www.mikeash.com/pyblog/objc_msgsends-new-prototype.html
作者=Mike Ash
原文日期=2019-10-11
译者=Nemocdz
校对=
定稿=

 <!--此处开始正文-->

苹果的新系统已经面世了。如果你已经浏览过文档，可能已经发现 [`objc_msgSend` 的原型被更改了](https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend)。之前，它被声明为接受参数 `id`、`SEL` 以及可变参数，并返回 `id` 的函数。现在，它被声明为接受和返回都是 `void` 的函数。类似的函数比如 `objc_msgSendSuper` 也被改成了 `void`/`void`。为什么要这样修改呢？

 <!--more-->

## 真正的原型

这背后其实隐藏着一个巨大且震惊的难题：`objc_msgSend` 的*真正*原型是什么？也就是说，它实际应该接受什么参数，返回什么结果？这个问题的答案并不简单。

你可能听说过 `objc_msgSend` 是用汇编实现的，因为它调用非常频繁，需要压榨任何一点点性能。这个说法是对的，但并不完整。它不可能在*任何*速度下的 C 里面实现。

`objc_msgSend` 的最快路径做了一些关键的事情：

1. 加载对象的类
2. 在该类的方法缓存中查找 selector
3. 跳转到缓存里找到的方法实现

从方法实现的角度，它看起来像是调用者直接调用了它。因为 `objc_msgSend` 直接跳转到方法实现而没有做函数调用，一旦完成工作就会巧妙地消失。这个实现小心地避开了任何用于传递参数到函数里的寄存器。调用者调用 `objc_msgSend` *就像*直接调用方法的实现一样，也和直接函数调用一样传递所有参数。一旦 `objc_msgSend` 找到实现并跳转，那些参数仍然处在实现所期望的位置上。当实现返回时，直接返回给调用者，且返回值由标准机制进行提供。

这解释了上述的问题：`objc_msgSend` 的方法原型应该是它最终所调用方法实现的原型。

等等，动态方法查找和消息传递的整个核心难道不是让你不知道调用时的方法实现么？这没错！然而，你确实知道了实现的*类型签名*。编译器从 `@interface` 或 `@protocol` 的代码块里的方法声明中获得这些信息，并用于生成对应参数传递和返回值的获取代码。如果你重写了一个方法，但你没有匹配对应的类型签名，编译器会发出警告。这可以通过隐藏声明或者在运行时添加方法来解决，在这种情况下，你可以最终使用类型签名和调用侧不匹配的方法实现。这类调用的表现会取决于两种类型签名在 ABI 层面如何进行匹配，可能是完全合理和正确的行为（如果 ABI 匹配，那么所有参数对齐），也可能是不可预测的行为（如果没有匹配）。

这揭露了本文问题的答案：旧的原型在某些情况下（当 ABI 匹配时）生效，但其他情况会奇怪地失效（当 ABI 不匹配时）。而新的原型需要你先转换为合适的类型，否则无法工作。只要你转换成正确的类型，它总是能正常工作。可以说，这个新方式鼓励以正确的方式使用，并提高了错误使用的门槛。

## 最小原型

尽管 `objc_msgSend` 的原型取决于调用的方法实现，但有两处是所有方法实现共通的：第一个参数总是 `id` 的 `self`，以及第二个参数总是 `SEL` 的 `_cmd`。附加参数的数量和各自的类型，以及返回值都是未知的，但前面这两个参数是已知的。`objc_msgSend` 需要这两条信息来执行消息派发，所以它们必须总在相同的位置以便能够被找到。

我们可以编写一个近似的 `objc_msgSend` 通用原型来表示：

```objective-c
 ??? objc_msgSend(id self, SEL _cmd, ???)
```

其中 `???` 表示未知的，它们取决于要调用的特定方法实现。当然，C 没有办法用类似这样的通配符来表示。

对于返回值，我们可以尝试选择通用的东西。由于 Objective-C 是面向对象的，因此可以假定返回值是 `id`：

```objective-c
 id objc_msgSend(id self, SEL _cmd, ???)
```

这不仅覆盖了返回值是对象的情况，也覆盖了 `void` 和其他类型但返回值没有被使用的情况。

那参数怎么办？C 实际上有一种方式来表示任意数量的任意类型参数，以可变参数函数原型的形式。参数列表末尾的省略号表示跟随的是可变数量的任意类型值：

```objective-c
id objc_msgSend(id self, SEL _cmd, ...)
```

这实际上就是最近更改之前原型的样子。

## ABI 不匹配

和运行时相关的问题是调用侧的 ABI 是否和方法实现侧的 ABI 匹配。也就是说，接受者是否会从调用者传递时的相同位置和格式取回对应参数？如果调用方将参数放入 `$rdx`，则实现需要从 `$rdx` 中取回该参数，否则就会造成损坏。

最小原型可能可以表达传递任意数量的任意类型这一概念，但为了实际在运行时工作，它需要使用和方法实现相同的 ABI。该实现几乎肯定使用的是不一样的原型，并且通常具有固定数量的参数。

这并不能保证可变参数函数的 ABI 和固定数量参数函数的 ABI 可以匹配。在某些平台上，它们可以完美匹配。但在其他的平台上，它们根本不匹配。

## Intel ABI

让我们看一个具体的例子。macOS 使用标准的 [x86-64 系统 V ABI](https://www.uclibc.org/docs/psABI-x86_64.pdf)。ABI 里有很多细节，但我们关注基本的就好。

参数被传入寄存器。整型参数按 `rdi`、`rsi`、`rdx`、`rcx`、`r8` 和 `r9` 顺序传入对应的寄存器。浮点型参数传入 `xmm0` 到 `xmm7` 的 SSE 寄存器。当调用可变参数方法时，`al` 寄存器会设置传递参数所用到 SSE 寄存器的数量值。整型返回值放在 `rax` 和 `rdx` 中，而浮点型返回值放在 `xmm0` 和 `xmm1` 中。

可变参数函数的 ABI 几乎和普通函数的 ABI 相同。除了传进 `al` 的 SSE 寄存器的数量值之外。 然而，当使用可变参数函数的 ABI 去调用普通函数时，这并没有影响，因为普通函数会忽略 `al` 的内容。

 C 语言让这事变得有点混乱。C 在某些类型作为可变参数传递时，会进行类型提升。比 `int` 小的整型（比如 `char` 和 `short`）会被提升成 `int`，`float` 会被提升成 `double`。如果你的方法签名包含这些类型，调用者就不可能用可变参数原型来传递清晰的类型。

对于整型，这并没有什么实际问题。整型会储存在合适寄存器的低位中，这些方式最终位都是在相同的位置上。然而，对于 `float` 是灾难性的。将更小的整型转换成 `int` 只需要填充额外的位就好了。将 `float` 转换为 `double` 涉及到将值完全转换到不同的结构。`float` 中的位和 `double` 中对应的位也不是对齐的。如果你尝试用可变参数原型来调用包含了 `float` 参数的不可变参数原型，该函数会接收到一个垃圾值。

为了说明这个问题，这里有一个简单的例子：

```objective-c
   // 使用旧的可变参数原型的 objc_msgSend。
    #define OBJC_OLD_DISPATCH_PROTOTYPES 1

    #import <Foundation/Foundation.h>
    #import <objc/message.h>

    @interface Foo : NSObject @end
    @implementation Foo
    - (void)log: (float)x {
        printf("%f\n", x);
    }
    @end

    int main(int argc, char **argv) {
        id obj = [Foo new];
        [obj log: (float)M_PI];
        objc_msgSend(obj, @selector(log:), (float)M_PI);
    }
```

会产生下面的输出：

```
    3.141593
    3370280550400.000000
```

就像你看到的那样，值在使用消息传递的方式时是正确的，但在使用显式的 `objc_msgSend` 调用传递后完全被弄乱了。

这可以通过为 `objc_msgSend` 转换正确的函数签名来补救。还记得 `objc_msgSend` 的实际原型其实是最终会被调用的方法吗，所以正确的使用方式是转换它为相应的函数指针类型。这样的调用是正确的：

```objective-c
((void (*)(id, SEL, float))objc_msgSend)(obj, @selector(log:), M_PI);
```

## ARM64 ABI

让我们看看另一个相关的例子。iOS 使用标准的 [ARM64 ABI 变体](https://developer.apple.com/library/archive/documentation/Xcode/Conceptual/iPhoneOSABIReference/Articles/ARM64FunctionCallingConventions.html)。

整型参数传入 `x0` 到 `x7` 的寄存器。浮点型参数传入` v0` 到 `v7` 寄存器。其余参数在栈上传递。返回值被放在传递参数的相同寄存器中。

这仅适用于正常参数。可变参数不会传入寄存器。它们总是在栈上传递，即使当参数寄存器是可用的。

无需通过实践来仔细分析它会如何工作。ABI 会完全不匹配，并且当一个方法调用未转换的 `objc_msgSend` 时会从参数重接收到垃圾值。

## 新的原型

新的原型简单而有趣：

```objective-c
void objc_msgSend(void);
```

这是完全不正确的形式。然而，旧的也一样。新的这个更加*显得*不正确，这是件好事。老的原型容易在不转换的情况下被使用，并且经常可以勉强工作，以至于你很容易以为所有事情是正确的。当你遇到有问题的情况时，bug 就会很难找到。

这个原型甚至不允许你传递 `self` 和 `_cmd` 这两个必要的参数。你完全可以不传入参数使用它，但它会马上崩溃，出了什么问题会变得显而易见。如果你尝试不转换使用它，编译器会发出警告，这比起出现奇怪且被破坏的参数值要好得多。

因为它仍然是个函数类型，你依旧可以转换为合适类型的函数指针，并使用该方式调用。只要使用的类型正确，它就会正确工作。

