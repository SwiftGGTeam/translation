title: "objc_msgSend 的新原型"
date: 
tags: [Objective-C,iOS]
categories: [Mike Ash]
permalink: objc_msgsends-new-prototype
keywords: objective-c, objc_msgSend, runtime
custom_title: "objc_msgSend 的新原型"

------

原文链接=https://www.mikeash.com/pyblog/objc_msgsends-new-prototype.html
作者=Mike Ash
原文日期=2019-10-11
译者=Nemocdz
校对=
定稿=

 <!--此处开始正文-->

苹果的新系统已经面世了。如果你已经浏览过文档，可能已经发现 [`objc_msgSend` 的原型被更改了](https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend)。之前，它被声明为接受参数 `id`、`SEL` 以及可变参数，并返回 `id` 的函数。现在，它被声明为接受和返回都是 `void` 的函数。类似的函数比如 `objc_msgSendSuper` 也被改成了 `void`/`void`。为什么要这样修改呢？

 <!--more-->

## 真正的原型

这背后其实隐藏着一个巨大且难以回答的问题：`objc_msgSend` 的*真正*原型是什么？也就是说，它实际应该接受什么参数，返回什么结果？这个问题的答案并不简单。

你可能听说过 `objc_msgSend` 是用汇编实现的，因为它调用非常频繁，需要压榨任何一点点性能。这个说法是对的，但并不完整。不管是*任何*速度的 C 都无法实现（译者注：无法实现并不只是因为性能问题，该比喻源于《Unsafe at Any Speed（任何速度的汽车都不安全）》这本书）。

`objc_msgSend` 主要做了几件事：

1. 加载对象的类
2. 在该类的方法缓存中查找 selector
3. 跳转到缓存里找到的方法实现

从方法实现的角度，它看起来像是调用者直接调用了它。因为 `objc_msgSend` 直接跳转到方法实现而没有做函数调用，一旦完成工作就会巧妙地消失。该实现小心地避开了任何用于传递参数到函数里的寄存器。调用者调用 `objc_msgSend` *就像*直接调用方法的实现一样，也和直接函数调用一样传递所有参数。一旦 `objc_msgSend` 找到实现并跳转，那些参数仍然处在实现所期望的位置上。当实现返回时，直接返回给调用者，且返回值由标准机制进行提供。

这解释了上述的问题：`objc_msgSend` 的方法原型应该是它最终所调用方法实现的原型。

等等，之所以使用动态方法查找和消息传递，不就是因为你不知道调用方法的具体实现么？没错！然而，你确实知道实现的*类型签名*。编译器从 `@interface` 或 `@protocol` 的代码块里的方法声明中获得这些信息，并用于生成对应参数传递和返回值的获取代码。如果重写了一个方法，但没有匹配对应的类型签名，编译器会发出警告。这可以通过隐藏声明或者在运行时添加方法来解决，在这种情况下，方法实现的类型签名会和调用侧的有所不同。此类调用的表现会取决于两种类型签名在 ABI 层面如何进行匹配，从完全合理和正确的行为（如果 ABI 匹配，那么所有参数对齐），到不可预测的行为（如果没有匹配）都有可能发生。

这揭露了本文问题的答案：旧的原型在某些情况下（当 ABI 匹配时）生效，但其他情况会奇怪地失效（当 ABI 不匹配时）。而新的原型需要你先转换为合适的类型，否则无法工作。只要你转换成正确的类型，它总是能正常工作。可以说，这个新方式鼓励以正确的方式使用，并提高了错误使用的门槛。

## 最小原型

尽管 `objc_msgSend` 的原型取决于调用的方法实现，但有两处是所有方法实现共通的：第一个参数总是 `id` 的 `self`，以及第二个参数总是 `SEL` 的 `_cmd`。附加参数的数量和类型都是未知的，返回值也一样，但前面这两个参数是已知的。`objc_msgSend` 需要这两条信息来执行消息派发，所以它们必须总在相同的位置以便能够被找到。

我们可以编写一个近似的 `objc_msgSend` 通用原型来表示：

```objective-c
 ??? objc_msgSend(id self, SEL _cmd, ???)
```

其中 `???` 表示未知，它们取决于要调用的特定方法实现。当然，C 没有办法用类似的通配符来表示。

对于返回值，我们可以尝试选择通用的东西。由于 Objective-C 是面向对象的，因此可以假定返回值是 `id`：

```objective-c
 id objc_msgSend(id self, SEL _cmd, ???)
```

这不仅覆盖了返回值是对象的情况，也覆盖了 `void` 和其他类型但返回值没有被使用的情况。

那参数怎么办？C 实际上有一种方式来表示任意数量的任意类型参数，以可变参数函数原型的形式。参数列表末尾的省略号表示跟随的是可变数量的任意类型值：

```objective-c
id objc_msgSend(id self, SEL _cmd, ...)
```

实际上这就是最近此次改动之前的原型。

## ABI 不匹配

和运行时相关的问题是调用侧的 ABI 是否和方法实现侧的 ABI 匹配。也就是说，接受者是否会从调用者传递时的相同位置和格式取回对应参数。如果调用方将参数放入 `$rdx`，则实现需要从 `$rdx` 中取回此参数，否则就会造成损坏。

最小原型可能可以表达传递任意数量的任意类型这一概念，但为了实际在运行时工作，它需要使用和方法实现相同的 ABI。此实现几乎能肯定使用的是不一样的原型，并且通常具有固定数量的参数。

这并不能保证可变参数函数的 ABI 和固定数量参数函数的 ABI 可以匹配。在某些平台上，它们可以完美匹配。但在其他的平台上，它们根本不匹配。

## Intel ABI

让我们看一个具体的例子。macOS 使用标准的 [x86-64 系统 V ABI](https://www.uclibc.org/docs/psABI-x86_64.pdf)。ABI 里有很多细节，但我们关注基本的就好。

参数被传入寄存器。整型参数按 `rdi`、`rsi`、`rdx`、`rcx`、`r8` 和 `r9` 顺序传入对应的寄存器。浮点型参数传入 `xmm0` 到 `xmm7` 的 SSE 寄存器。当调用可变参数方法时，`al` 寄存器会设置传递参数所用到 SSE 寄存器的数量值。整型返回值放在 `rax` 和 `rdx` 中，而浮点型返回值放在 `xmm0` 和 `xmm1` 中。

可变参数函数的 ABI 几乎和普通函数的 ABI 相同。除了传进 `al` 的 SSE 寄存器的数量值之外。 然而，当使用可变参数函数的 ABI 去调用普通函数时，并不会有问题，因为普通函数会忽略 `al` 的内容。

 C 语言让此事变得有点混乱。C 在某些类型作为可变参数传递时，会进行类型提升。比 `int` 小的整型（比如 `char` 和 `short`）会被提升成 `int`，`float` 会被提升成 `double`。如果你的方法签名包含这些类型，调用者就不可能用可变参数原型来传递清晰的类型。

对于整型，并没有什么实际问题。整型会储存在合适寄存器的低位中，这些方式最终位都是在相同的位置上。然而，对于 `float` 是灾难性的。将更小的整型转换成 `int` 只需要填充额外的位就好了。将 `float` 转换为 `double` 涉及到将值完全转换到不同的结构。`float` 中的位和 `double` 中对应的位也不是对齐的。如果你尝试用可变参数原型来调用包含了 `float` 参数的不可变参数原型，该函数会接收到一个垃圾值。

为了说明这个问题，举一个简单的例子：

```objective-c
// 使用旧的可变参数原型的 objc_msgSend。
#define OBJC_OLD_DISPATCH_PROTOTYPES 1

#import <Foundation/Foundation.h>
#import <objc/message.h>

@interface Foo : NSObject @end
@implementation Foo
- (void)log: (float)x {
		printf("%f\n", x);
}
@end

int main(int argc, char **argv) {
		id obj = [Foo new];
    [obj log: (float)M_PI];
    objc_msgSend(obj, @selector(log:), (float)M_PI);
}
```

会产生下面的输出：

```
3.141593
3370280550400.000000
```

就像你看到的那样，值在使用消息传递的方式时是正确的，但在使用显式的 `objc_msgSend` 调用传递后完全被弄乱了。

这可以通过为 `objc_msgSend` 转换正确的函数签名来补救。还记得 `objc_msgSend` 的实际原型其实是最终会被调用的方法吗，所以正确的使用方式是转换它为相应的函数指针类型。这样的调用是正确的：

```objective-c
((void (*)(id, SEL, float))objc_msgSend)(obj, @selector(log:), M_PI);
```

## ARM64 ABI

让我们看看另一个相关的例子。iOS 使用标准的 [ARM64 ABI 变体](https://developer.apple.com/library/archive/documentation/Xcode/Conceptual/iPhoneOSABIReference/Articles/ARM64FunctionCallingConventions.html)。

整型参数传入 `x0` 到 `x7` 的寄存器。浮点型参数传入` v0` 到 `v7` 寄存器。其余参数在栈上传递。返回值被放在传递参数的相同寄存器中。

这仅适用于正常参数。可变参数不会传入寄存器。它们总是在栈上传递，即使当参数寄存器是可用的。

无需通过实践来仔细分析它会如何工作。ABI 会完全不匹配，并且当一个方法调用未转换的 `objc_msgSend` 时会从参数重接收到垃圾值。

## 新的原型

新的原型简单而有趣：

```objective-c
void objc_msgSend(void);
```

这是完全不正确的形式。然而，旧的也一样。新的这个更加*显得*不正确，这是件好事。老的原型容易在不转换的情况下被使用，并且经常可以勉强工作，以至于你很容易以为所有事情是正确的。当你遇到有问题的情况时，bug 就会很难找到。

这个原型甚至不允许你传递 `self` 和 `_cmd` 这两个必要的参数。你完全可以不传入参数使用它，但它会马上崩溃，出了什么问题会变得显而易见。如果你尝试不转换使用它，编译器会发出警告，这比起出现奇怪且被破坏的参数值要好得多。

因为它仍然是个函数类型，你依旧可以转换为合适类型的函数指针，并使用该方式调用。只要使用的类型正确，它就会正确工作。

