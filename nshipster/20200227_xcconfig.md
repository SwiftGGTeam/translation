title: "Xcode 编译配置文件"
date: 
tags: [Xcode]
categories: [Xcode]
permalink: xcconfig
keywords: Xcode,编译配置文件,xcconfig
custom_title: Xcode 编译配置文件
description: 软件开发最佳实践中规定配置要与代码分离。学习如何用 `xcconfig` 文件，让你的项目具有更好的内聚能力、更清晰易懂，也更加强大。

---
原文链接=https://nshipster.com/xcconfig/
作者=Mattt
原文日期=2020-02-27
译者=ericchuhong
校对=
定稿=

<!--此处开始正文-->

软件开发最佳实践中 [规定](https://12factor.net/config) 配置要与代码分离。但是在 Apple 平台的开发者经常需要花很大力气将这些规范和 Xcode 繁重的项目工作流整合起来。

了解每个项目设置的作用是什么，以及它们间是如何相互影响的，是一项需要多年磨练的技能。而事实上，无论在 Xcode 的 GUI 上研究多么深入，都对我们没帮助。

<!--more-->

打开项目编辑器的 “Build Settings” 标签，你会看到*上百条*编译设置，其中含括了有 project、targets 和配置——*更不用说其他的* *6* *个标签了！*

![xcconfig-project-build-settings--light](https://nshipster.com/assets/xcconfig-project-build-settings--light-f7043782f0b56d637bec89eefa0d37939b38ef33f55c293e326d3fecbc06df49.png)

还好我们有一个更好的方式来管理这些配置，而不用点击迷宫般的标签和一个个箭头。
这一周，我们会给你展示如何使用基于文本的 `xcconfig` 文件，来表示 Xcode 中的编译设置，从而让你的项目具有更好的内聚性、更清晰易懂，也更加强大。

> 到 [XcodeBuildSettings.com](https://xcodebuildsettings.com) 查看最新版本 Xcode 支持的所有编译设置参考。

* * *

[Xcode 编译配置文件](https://help.apple.com/xcode/mac/8.3/#/dev745c5c974)，更常被大家所认知的是它们的 `xcconfig` 文件扩展，可以让你不用 Xcode 就能声明和管理你应用的编译设置。它们是纯文本，意味着它们对版本管理系统更加友好，并且能被任意编辑器修改。

通常来说，每一个配置文件包含了一组带有以下语法的键值对：

```xcconfig
<#BUILD_SETTING_NAME#> = <#value#>
```

例如，要想指定一个项目的 Swift 语言版本，你需要像这样指定 `SWIFT_VERSION` 编译设置：

```xcconfig
SWIFT_VERSION = 5.0
```

> 根据 [POSIX 标准](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08) 环境变量的名字仅由大写字母、数字和下划线（`_`）组成 - 我喜欢叫它做 `SCREAMING_SNAKE_CASE` 🐍🗯 命名法。

* * *

乍一看，`xcconfig` 文件与 `.env` 文件非常相似，均有简单的换行分隔语法。但是 Xcode 编译配置文件远不止我们所见的这些。_看着！_

### 保留已有的值

追加而不是替换已有定义，可以像这样使用 `$(inherited)`：

```xcconfig
<#BUILD_SETTING_NAME#> = $(inherited)<#additional value#>
```

下面这样做通常是为了建立一组值，例如让编译器搜索框架中已包含的头文件
（`FRAMEWORK_SEARCH_PATHS`）：

```xcconfig
FRAMEWORK_SEARCH_PATHS = $(inherited) $(PROJECT_DIR)
```

Xcode 会按以下的顺序传递继承的值（由低到高）：

- Platform Defaults
- Xcode Project xcconfig File
- Xcode Project File Build Settings
- Target xcconfig File
- Target Build Settings

> 空格用于分隔字符串和路径列表中的项。如果想要指定一个包含有空格的项，你必须用引号（`"`）把它括起来。

### 引用值

你可以通过下面的语法用声明的名字替换其他设置的值：

```xcconfig
<#BUILD_SETTING_NAME#> = $(<#ANOTHER_BUILD_SETTING_NAME#>)
```

替换也可以用于根据已经存在的值定义新的变量，或者用内联的方式动态构建新的值

```xcconfig
OBJROOT = $(SYMROOT)
CONFIGURATION_BUILD_DIR = $(BUILD_DIR)/$(CONFIGURATION)-$(PLATFORM_NAME)
```

### 给引用编译设置赋后备值

在 Xcode 11.4 及更新的版本，你可以使用 `default` 求值运算符指定一个后备值，让其在引用的编译设置运算结果为空时使用。

```xcconfig
$(<#BUILD_SETTING_NAME#>:default=<#value#>)
```

### 条件化编译设置

你可以使用以下语法，来根据 SDK（`sdk`）、架构（`arch`）和/或配置（`config`）来对编译设置进行条件化：

```xcconfig
<#BUILD_SETTING_NAME#>[sdk=<#sdk#>] = <#value for specified sdk#>
<#BUILD_SETTING_NAME#>[arch=<#architecture#>] = <#value for specified architecture#>
<#BUILD_SETTING_NAME#>[config=<#configuration#>] = <#value for specified configuration#>
```

当需要在多个相同的编译设置定义中做出一个选择时，编译器会根据特定的情况进行决策。

```xcconfig
<#BUILD_SETTING_NAME#>[sdk=<#sdk#>][arch=<#architecture#>] = <#value for specified sdk and architectures#>
<#BUILD_SETTING_NAME#>[sdk=*][arch=<#architecture#>] = <#value for all other sdks with specified architecture#>
```

例如，你可以指定下述的编译设置，只编译当前可用的架构，以提高本地编译速度：

```xcconfig
ONLY_ACTIVE_ARCH[config=Debug][sdk=*][arch=*] = YES
```

# 从其它配置文件引入编译设置

这个功能主要是基于一个和 `C` 语言中等效的指令 `#include`，从其他配置文件引入编译设置：

```xcconfig
#include "<#path/to/File.xcconfig#>"
```

正如我们将在下文会看到的，你可以利用这一点，以非常强大的方式构建编译设置的级联列表。

```
通常当编译器遇到无法解析的 `include` 指令时，它会抛出异常。但是 `xcconfig` 文件也支持 `#include?` 指令，如果找不到文件则不会有任何问题。

在很多情况下，你不会希望文件的存在与否会改变编译时的行为；毕竟，在编译时就可被预测才是最好的方式。但你可以用它来为像 [Reveal](https://revealapp.com/) 这类可选开发工具实现一个 hook，使用下面的配置。

```

```xcconfig
# Reveal.xcconfig
OTHER_LDFLAGS = $(inherited) -weak_framework RevealServer
FRAMEWORK_SEARCH_PATHS = $(inherited) /Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries
```

## 创建编译设置文件

要创建编译配置文件，选择“File > New File...”菜单选项（`⌘`+`N`），向下滚动到标有“other”的部分，然后选择 Configuration Settings File 模板。下一步，将其保存到项目目录中的某个位置，确保将其添加到所需的 target 中。

![xcconfig-new-file--light](https://nshipster.com/assets/xcconfig-new-file--light-1569134f8ecaeaee6640f28e544443da0136ff72b00f9343126147934ac134d4.png)

一旦你创建好了一份 `xcconfig` 文件，你可以在它关联 target 中，分配给它一份或者多份编译配置。

![xcconfig-project-configurations--light](https://nshipster.com/assets/xcconfig-project-configurations--light-a82440e27f27e3b139ab51c7317780c6b4a017dfcc56532972da5d521f1f0988.png)

> 编译配置文件不应该被包含在你的任一项目 targets 中。如果你在应用的 `.ipa` 归档文件中发现 `.xcconfig` 文件，确保它们不是任何 targets 的配置文件，并且确保其不会出现在任何的 "Copy Bundle Resources" 构建阶段中。

* * *

既然我们已经介绍了使用 Xcode 编译配置文件的基本知识，那么让我们来看几个示例，说明一下如何使用它们来管理开发、阶段和生产环境。

* * *

## 自定义内部版本的应用程序名称和图标

开发 iOS 应用通常需要在模拟器和测试设备上处理各种内部版本（以及 App Store 的最新版本作为参考）。

您可以使用 `xcconfig` 文件简化您的工作，它会给每个配置分配一个不同的名称和应用图标。

```xcconfig
// Development.xcconfig
PRODUCT_NAME = $(inherited) α
ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon-Alpha

//////////////////////////////////////////////////

// Staging.xcconfig
PRODUCT_NAME = $(inherited) β
ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon-Beta
```

## 跨环境管理常量

如果你的后端开发人员们按前面提到的 [12 Factor App](https://12factor.net/confi)）那样做，那么他们将会有独立的终端用于开发、阶段和生产的环境。

在 iOS 平台上，要想管理这些环境，最常见的方法可能是使用条件编译语句编译设置，诸如 `DEBUG` 之类的。

```swift
import Foundation

#if DEBUG
let apiBaseURL = URL(string: "https://api.staging.example.com")!
#else
let apiBaseURL = URL(string: "https://api.example.com")!
#endif
```

这样做虽然已经足够完成我们的需求，但却违背了代码/配置分离的原则。

另一种方法就是将这些特定于环境的值放入到 `xcconfig` 文件中。

```xcconfig
// Development.xcconfig
API_BASE_URL = api.staging.example.com

//////////////////////////////////////////

// Production.xcconfig
API_BASE_URL = api.example.com
```

> `xcconfig` 将 `//` 视为注释分隔符, 不管它是否被括在引号中。如果你尝试用反斜杠 `/\/` 进行转义，那这些反斜杠只会按字面描述进行显示，但在处理后的值中又必须将其删除。当需要指定每个环境的 URL 常量时，这尤其不方便。

> 如果你不想处理这种不幸的行为，则可以省略该方案并在代码中预先改成 `https://`。_（你应该在用 https... 的吧?）_


但是，要以代码的方式获得这些值，我们还需要执行一个额外的步骤：

### 用 Swift 读取编译设置

Xcode 项目文件编译设置、`xcconfig` 文件和环境变量都只有在编译时才能获得。当编译好的应用运行起来后，编译时的上下文环境就都不可用了。_（幸好是这样！）_

等一下 - 你还记得在其他选项卡里有一些别的编译设置吗？Info，不就是它吗？

在 target 中，这个 Info 选项卡实际上碰巧是 `Info.plist` 文件一个别致的展示形式。在编译阶段，`Info.plist` 文件将根据提供的编译设置进行编译，并复制到生成的 app [bundle](https://nshipster.com/bundles-and-packages/) 中。因此，通过添加对 `$(API_BASE_URL)` 的引用，你可以从 Foundation 框架的 `Bundle` 接口中的 `infoDictionary` 属性访问这些设置的值。_真整洁！_

![xcconfig-project-info-plist--light](https://nshipster.com/assets/xcconfig-project-info-plist--light-9bf503aa924ea851548f74ba3007aed1e9cd732f0f2a1861ca57ef9934fafbf5.png)

按照这种做法，我们可以这样做：

```swift
import Foundation

enum Configuration {
    enum Error: Swift.Error {
        case missingKey, invalidValue
    }

    static func value<T>(for key: String) throws -> T where T: LosslessStringConvertible {
        guard let object = Bundle.main.object(forInfoDictionaryKey:key) else {
            throw Error.missingKey
        }

        switch object {
        case let value as T:
            return value
        case let string as String:
            guard let value = T(string) else { fallthrough }
            return value
        default:
            throw Error.invalidValue
        }
    }
}

enum API {
    static var baseURL: URL {
        return try! URL(string: "https://" + Configuration.value(for: "API_BASE_URL"))!
    }
}
```

从调用方来看，这个做法可以和我们的最佳实践完美地结合在一起 — 没有一个单独的硬编码常量！

```swift
let url = URL(string: path, relativeTo: API.baseURL)!
var request = URLRequest(url: url)
request.httpMethod = method
```


> 别用 `xcconfig` 存储像 API keys 或者其他凭证之类的密钥。相关的信息，请查阅我们关于 [iOS 密钥管理](https://nshipster.com/secrets/) 的文章。

* * *

Xcode 的项目是大型集中化的，但脆弱又封闭。它们是团队成员之间协作的矛盾源，并且经常成为我们工作的阻力。

幸运的是，`xcconfig` 在很大程度上解决了这些问题。将配置从 Xcode 中移到 `xcconfig` 会带来很多好处，也提供了一种隔离项目和 Xcode 工作流的方式，同时不会偏离 Cupertino 允许的 “康庄大道”。