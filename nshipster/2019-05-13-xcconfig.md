---
title: Xcode Build Configuration Files
author: Mattt
category: Xcode
excerpt: >-
  Software development best practices prescribe 
  strict separation of configuration from code.
  Learn how you can use `xcconfig` files 
  to make your Xcode projects more compact, comprehensible, and powerful.
status:
  swift: 5.0
---

---
title: Xcode Build 配置文件
author: Mattt
category: Xcode
excerpt: >-
  软件开发最佳实践规定了配置与代码的严格分离。学习如何使用 `xcconfig` 文件让你的 Xcode 项目更加紧凑、易懂、强大。
status:
  swift: 5.0
---

Software development best practices
[prescribe](https://12factor.net/config)
strict separation of configuration from code.
Yet developers on Apple platforms
often struggle to square these guidelines with Xcode's project-heavy workflow.

软件开发最佳实践 [规定了](https://12factor.net/config) 配置与代码的严格分离。然而，苹果平台上的开发人员常常难以将这些指导原则与 Xcode 繁重的项目工作流程结合起来。

Understanding what each project setting does
and how they all interact with one another
is a skill that can take years to hone.
And the fact that much of this information
is buried deep within the GUIs of Xcode does us no favors.

了解每个项目设置的功能以及它们之间如何交互，是一项需要多年磨练的技能。但 Xcode 将大部分的这类信息都都深埋在其图形化界面中，这对我们没有任何好处。

Navigate to the "Build Settings" tab of the project editor,
and you'll be greeted by _hundreds_ of build settings
spread across layers of projects, targets, and configurations ---
_and that's to say nothing of the other six tabs!_

导航到项目编辑器的 "Build Settings" tab，你会看到分布在 project、target 和 configuration 上的 _数百条_ Build Setting（构建配置） —— _更别说其他六个 tab 了!_

<picture>
    <source srcset="{% asset xcconfig-project-build-settings--dark.png @path %}" media="(prefers-color-scheme: dark)">
    <img src="{% asset xcconfig-project-build-settings--light.png @path %}" alt="Xcode build settings">
</picture>

![](https://nshipster.com/assets/xcconfig-project-build-settings--light-f7043782f0b56d637bec89eefa0d37939b38ef33f55c293e326d3fecbc06df49.png)

Fortunately,
there's a better way to manage all of this configuration
that doesn't involve clicking through a maze of tabs and disclosure arrows.

幸运的是，有一个更好的办法，不必点击迷宫般的 tab 和箭头，就可以管理所有的配置。

This week,
we'll show you how you can use text-based `xcconfig` files
to externalize build settings from Xcode
to make your projects more compact, comprehensible, and powerful.

这一周，我们将向你展示如何在 Xcode 之外，通过修改基于文本的 `xcconfig` 文件，让你的项目更加紧凑、易懂、强大。

---

[Xcode build configuration files](https://help.apple.com/xcode/mac/8.3/#/dev745c5c974),
more commonly known by their `xcconfig` file extension,
allow build settings for your app to be declared and managed without Xcode.
They're plain text,
which means they're much friendlier to source control systems
and can be modified with any editor.

[Xcode Build 配置文件](https://help.apple.com/xcode/mac/8.3/#/dev745c5c974)，即大家所知的 `xcconfig` 文件，允许我们在不使用 Xcode 的情况下声明和管理 APP 的 Build Setting。它们是纯文本的，这意味着它们对代码管理系统更加友好，而且可以被任意编辑器修改。

Fundamentally,
each configuration file consists of a sequence of key-value assignments
with the following syntax:

从根本上说，每个配置文件都由一系列键值对组成，其语法如下:

```
<#BUILD_SETTING_NAME#> = <#value#>
```

For example,
to specify the Swift language version for a project,
you'd specify the `SWIFT_VERSION` build setting like so:

例如，你可以通过下面这样的 `SWIFT_VERSION` Build Setting，指定项目的 Swift 语言版本：

```
SWIFT_VERSION = 5.0
```

{% info %}

According to the [<abbr title="Portable Operating System Interface">POSIX</abbr> standard](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08)
environment variables have names consisting solely of
uppercase letters, digits, and underscore (`_`) ---
a convention I like to call `SCREAMING_SNAKE_CASE` 🐍🗯.

> 根据 [<abbr title="Portable Operating System Interface">POSIX</abbr> 标准](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08)，环境变量的名字由全大写字母、数字和下划线（`_`）组成 —— 经典例子就是 `SCREAMING_SNAKE_CASE` 🐍🗯。

{% endinfo %}

---

At first glance,
`xcconfig` files bear a striking resemblance to `.env` files,
with their simple, newline-delimited syntax.
But there's more to Xcode build configuration files than meets the eye.
_Behold!_

乍一看，`xcconfig` 文件与 `.env` 文件有惊人的相似之处，它们的语法都很简单，都以换行分隔。但是，Xcode Build 配置文件的内容比表面上看到的要多。_看哪!_

### Retaining Existing Values

### 保留现有值

To append rather than replace existing definitions,
use the `$(inherited)` variable like so:

要追加新内容，而不是替换现有定义时，可以像这样使用 `$(inherited)` 变量:

```
<#BUILD_SETTING_NAME#> = $(inherited)<#additional value#>
```

You typically do this to build up lists of values,
such as the paths in which
the compiler searches for frameworks
to find included header files
(`FRAMEWORK_SEARCH_PATHS`):

这么做通常是为了搭建一些值的列表，比如编译器的 framework 头文件的搜索路径(`FRAMEWORK_SEARCH_PATHS`):

```
FRAMEWORK_SEARCH_PATHS = $(inherited) $(PROJECT_DIR)
```

Xcode assigns inherited values in the following order
(from lowest to highest precedence):

Xcode 按下面的顺序对 `inherited` 进行赋值（优先级从低到高）：

- Platform Defaults
- Xcode Project File Build Settings
- xcconfig File for the Xcode Project
- Active Target Build Settings
- xcconfig File for the Active Target

- 平台默认值（Platform Defaults）
- Xcode 项目文件的 Build Setting（Xcode Project File Build Settings）
- Xcode 项目的 xcconfig 文件（xcconfig File for the Xcode Project）
- Active Target 的 Build Setting（Active Target Build Settings）
- Active Target 的 xcconfig 文件（xcconfig File for the Active Target）

{% info %}
Spaces are used to delimit items in string and path lists.
To specify an item containing whitespace,
you must enclose it with quotation marks (`"`).

> 空格用于分隔字符串和路径列表中的项。指定包含空格的项时，必须用引号(`"`)括起来。

{% endinfo %}

### Referencing Values

### 引用其他值

You can substitute values from other settings
by their declaration name
with the following syntax:

你可以按照下面的语法，通过其他设置的名字引用它们的值：

```
<#BUILD_SETTING_NAME#> = $(<#ANOTHER_BUILD_SETTING_NAME#>)
```

Substitutions can be used to
define new variables according to existing values,
or inline to build up new values dynamically.

这种引用可以用于根据现有值定义新变量，也可以用于以内联方式动态构建新值。

```
OBJROOT = $(SYMROOT)
CONFIGURATION_BUILD_DIR = $(BUILD_DIR)/$(CONFIGURATION)-$(PLATFORM_NAME)
```

### Conditionalizing

### 条件约束

You can conditionalize build settings according to their
SDK (`sdk`), architecture (`arch`), and / or configuration (`config`)
according to the following syntax:

使用以下语法，你可以按 SDK (`sdk`)、架构 (`arch`)和 / 或配置(`config`)对 Build Setting 进行条件约束：

```
<#BUILD_SETTING_NAME#>[sdk=<#sdk#>] = <#value for specified sdk#>
<#BUILD_SETTING_NAME#>[arch=<#architecture#>] = <#value for specified architecture#>
<#BUILD_SETTING_NAME#>[config=<#configuration#>] = <#value for specified configuration#>
```

Given a choice between multiple definitions of the same build setting,
the compiler resolves according to specificity.

如果需要在同一 Build Setting 的多个定义之间进行选择，编译器将根据条件约束进行解析。

```
<#BUILD_SETTING_NAME#>[sdk=<#sdk#>][arch=<#architecture#>] = <#value for specified sdk and architectures#>
<#BUILD_SETTING_NAME#>[sdk=*][arch=<#architecture#>] = <#value for all other sdks with specified architecture#>
```

For example,
you might specify the following build setting
to speed up local builds by only compiling for the active architecture:

例如，你可以使用下面这条 Build Setting 指定仅编译 active architecture，从而提升本地 Build 的速度。

```
ONLY_ACTIVE_ARCH[config=Debug][sdk=*][arch=*] = YES
```

### Including Settings from Other Configuration Files

### 引用其他配置文件中的设置

A build configuration file can include settings from other configuration files
using the same `#include` syntax
as the equivalent `C` directive
on which this functionality is based:

跟 `C` 语言的 `#include` 指令一样，Build 配置文件也可以使用这种语法来引用其他配置文件中的设置。

```
#include "<#path/to/File.xcconfig#>"
```

As we'll see later on in the article,
you can take advantage of this to build up cascading lists of build settings
in really powerful ways.

正如我们将在本文后面看到的，你可以利用这一点，以非常强大的方式搭建起 Build Setting 的级联列表。

{% info %}
Normally when the compiler encounters an `#include` directive
that can't be resolved,
it raises an error.
But `xcconfig` files also support an `#include?` directive,
that doesn't complain if the file can't be found.

> 正常来说，当遇到一个无法解析的 `#include` 指令时，编译器会报错。但是 `xcconfig` 文件同时也支持 `#include?` 指令，在该指令下，若文件无法找到，编译器不会报错。

There aren't many cases in which you'd want
the existence or nonexistence of a file
to change compile-time behavior;
after all, builds are best when they're predictable.
But you might use this
as a hook for optional development tools like [Reveal](https://revealapp.com/),
which requires the following configuration:

> 根据文件是否存在而改变编译时行为的情况并不多；毕竟，Build 最好是可预见的。但是你可以把它用在可选的开发工具上，比如 [Reveal](https://revealapp.com/) 需要以下的配置：

> ```
> # Reveal.xcconfig
> OTHER_LDFLAGS = $(inherited) -weak_framework RevealServer
> FRAMEWORK_SEARCH_PATHS = $(inherited) /Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries
> ```

{% endinfo %}

## Creating Build Configuration Files

## 创建 Build 配置文件

To create a build configuration file,
select the "File > New File..." menu item (<kbd>⌘</kbd><kbd>N</kbd>),
scroll down to the section labeled "Other",
and select the Configuration Settings File template.
Next, save it somewhere in your project directory,
making sure to add it to your desired targets

要创建 Build 配置文件，请选择 "File > New File..." 菜单项（<kbd>⌘</kbd><kbd>N</kbd>），下拉到 "Other" 部分，选中 Configuration Settings File 模板。将它保存到你的项目目录，并确保它在你期望的 target 上。

<picture>
    <source srcset="{% asset xcconfig-new-file--dark.png @path %}" media="(prefers-color-scheme: dark)">
    <img src="{% asset xcconfig-new-file--light.png @path %}" alt="Xcode new configuration file">
</picture>

![](https://nshipster.com/assets/xcconfig-new-file--light-1569134f8ecaeaee6640f28e544443da0136ff72b00f9343126147934ac134d4.png)

Once you've created an `xcconfig` file,
you can assign it to one or more build configurations
for its associated targets.

创建好 `xcconfig` 文件后，你就可以将它分配给对应 target 的一个或多个 Build 配置。

<picture>
    <source srcset="{% asset xcconfig-project-configurations--dark.png @path %}" media="(prefers-color-scheme: dark)">
    <img src="{% asset xcconfig-project-configurations--light.png @path %}" alt="Xcode project configuration">
</picture>

![](https://nshipster.com/assets/xcconfig-project-configurations--light-a82440e27f27e3b139ab51c7317780c6b4a017dfcc56532972da5d521f1f0988.png)

---

Now that we've covered the basics of using Xcode build configuration files
let's look at a couple of examples of how you can use them
to manage development, stage, and production environments.

现在我们已经介绍了 Xcode Build 配置文件使用的基础知识，那么让我们来看几个示例，看看如何使用它们来管理 development、stage 和 production 环境。

---

## Customizing App Name and Icon for Internal Builds

## 为内部版本提供自定义的 APP 名称和图标

Developing an iOS app usually involves
juggling various internal builds
on your simulators and test devices
(as well as the latest version from the App Store,
to use as a reference).

开发 iOS 应用程序时，通常需要在模拟器和测试设备上安装各种内部版本（同时也会安装应用程序商店的最新版本，以供参考）。

You can make things easier on yourself
with `xcconfig` files that assign each configuration
a distinct name and app icon.

使用 `xcconfig` 文件，你可以轻松地为每个配置分配一个不同的名称和 APP 图标。

```
// Development.xcconfig
PRODUCT_NAME = $(inherited) α
ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon-Alpha

---

// Staging.xcconfig
PRODUCT_NAME = $(inherited) β
ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon-Beta
```

## Managing Constants Across Different Environments

## 管理不同环境下的常量

If your backend developers comport themselves according to the aforementioned
[12 Factor App](https://12factor.net/config) philosophy,
then they'll have separate endpoints for
development, stage, and production environments.

如果你的后端开发人员也遵循前面提到的 [12 Factor App](https://12factor.net/config) 理论，那么他们将为 development、stage 和 production 环境提供单独的接口。

On iOS,
perhaps the most common approach to managing these environments
is to use conditional compilation statements
with build settings like `DEBUG`.

iOS 上最常见的环境管理方式可能就是使用条件编译语句 + `DEBUG` 这样的 Build Setting 了。

```swift
import Foundation

#if DEBUG
let apiBaseURL = URL(string: "https://api.example.dev")!
let apiKey = "9e053b0285394378cf3259ed86cd7504"
#else
let apiBaseURL = URL(string: "https://api.example.com")!
let apiKey = "4571047960318d233d64028363dfa771"
#endif
```

This gets the job done,
but runs afoul of the canon of code / configuration separation.

这只是完成了任务，但是与代码 / 配置分离的标准相冲突。

An alternative approach takes these environment-specific values
and puts them where they belong ---
into `xcconfig` files.

另一个方案是将这些与环境相关的值放到它们该待的地方 —— `xcconfig` 文件中。

```
// Development.xcconfig
API_BASE_URL = api.example.dev
API_KEY = 9e053b0285394378cf3259ed86cd7504

---

// Production.xcconfig
API_BASE_URL = api.example.com
API_KEY = 4571047960318d233d64028363dfa771
```

{% error %}

Unfortunately, `xcconfig` files treat the sequence
`//` as a comment delimiter,
regardless of whether it's enclosed in quotation marks.
If you try to escape with backslashes `\/\/`,
those backslashes show up literally
and must be removed from the resulting value.
This is especially inconvenient when specifying per-environment URL constants.

> 不幸的是，`xcconfig` 将所有 `//` 都当成注释分隔符，不管它们是否包括在引号中。如果你用反斜线 `\/\/` 进行转义，那么这些反斜线也将被直接展示出现，使用时必须从结果中移除。在指定每个环境的 URL 常量时，这尤其不方便。

If you'd rather not work around this unfortunate behavior,
you can always omit the scheme and prepend `https://` in code.
_(You are using https... right?)_

> 如果不想处理这种麻烦的事情，你可以在 `xcconfig` 中忽略 scheme，然后在代码中添加 `https://`。_（你是在使用 https……对吧？）_

{% enderror %}

However,
to pull these values programmatically,
we'll need to take one additional step:

然而，要以编程方式获取这些值，我们还需要一个额外的步骤:

### Accessing Build Settings from Swift

### 在 Swift 中访问 Build Setting

Build settings defined by
the Xcode project file, `xcconfig` files, and environment variables,
are only available at build time.
When you run the compiled app,
none of that surrounding context is available.
_(And thank goodness for that!)_

由 Xcode 项目文件、`xcconfig` 文件和环境变量定义的 Build Setting 只在 Build 时可用。当你运行一个已经编译的 APP 时，所有相关的上下文都是不可见的。_（谢天谢地！）_

But wait a sec ---
don't you remember seeing some of those build settings before
in one of those other tabs?
Info, was it?

但是等一下——你不记得之前在其他选项卡中看到过一些 Build Setting 吗？Info，是吗？

As it so happens,
that info tab is actually just a fancy presentation of
the target's `Info.plist` file.
At build time,
that `Info.plist` file is compiled
according to the build settings provided
and copied into the resulting app [bundle](/bundles-and-packages/).
Therefore,
by adding references to `$(API_BASE_URL)` and `$(API_KEY)`,
you can access the values for those settings
through the `infoDictionary` property of Foundation's `Bundle` API.
_Neat!_

实际上，Info tab 只是 target 的 `Info.plist` 文件的一个马甲。Build 时，这个 `Info.plist` 文件会根据 Build Setting 的配置进行编译，然后复制到最终 APP 的 [bundle](https://nshipster.com/bundles-and-packages/) 中。因此，添加 `$(API_BASE_URL)` 和 `$(API_KEY)` 的引用后，你可以通过 Foundation `Bundle` API 的 `infoDictionary` 属性访问这些值。完美！

<picture>
    <source srcset="{% asset xcconfig-project-info-plist--dark.png @path %}" media="(prefers-color-scheme: dark)">
    <img src="{% asset xcconfig-project-info-plist--light.png @path %}" alt="Xcode Info.plist">
</picture>

![](https://nshipster.com/assets/xcconfig-project-info-plist--light-5561d8abf4dca9722875ff1f62b5975c3361f5ea3dfd584b655f3da7d3ceb94b.png)

Following this approach,
we might do something like the following:

按照这种方法，我们可以做如下工作：

```swift
import Foundation

enum Configuration {
    static func value<T>(for key: String) -> T {
        guard let value = Bundle.main.infoDictionary?[key] as? T else {
            fatalError("Invalid or missing Info.plist key: \(key)")
        }

        return value
    }
}

enum API {
    static var baseURL: URL {
        return URL(string: "https://" + Configuration.value(for: "API_BASE_URL"))!
    }

    static var key: String {
        return Configuration.value(for: "API_KEY")
    }
}
```

When viewed from the call site,
we find that this approach harmonizes beautifully
with our best practices ---
not a single hard-coded constant in sight!

从调用的角度考虑，我们发现这种方法与我们的最佳实践完美地在结合一起 —— 没有出现一个硬编码的常量!

```swift
let url = URL(string: path, relativeTo: API.baseURL)!
var request = URLRequest(url: url)
request.httpMethod = method
request.addValue(API.key, forHTTPHeaderField: "X-API-KEY")
```

{% warning %}

Don't commit secrets to source code.
Instead,
store them securely in a password manager or the like.

> 不要把私密的东西写在代码中。相反，应该将它们安全地存储在密码管理器或类似的东西中。

To prevent secrets from leaking onto GitHub,
add the following to your `.gitignore` file
(as appropriate):

> 为了防止你的私密被泄漏到 GitHub 上，请将下列配置添加到你的 `.gitignore` 文件中（根据需要）：

> ```
> # .gitignore
> Development.xcconfig
> Staging.xcconfig
> Production.xcconfig
> ```

In place of those files,
some developers like to have placeholder files
(e.g. `Development.sample.xcconfig`)
with all of the expected keys.
When checking out the repository,
the developer copies this file to the non-placeholder location
and fills it out accordingly.


> 一些开发人员喜欢使用包含了所需 key 的占位符文件（例如 Development.sample.xcconfig）代替这些文件。拉取代码时，开发人员再将该文件复制到非占位符位置，并相应地填充它。

{% endwarning %}

---

---

Xcode projects are monolithic, fragile, and opaque.
They're a source of friction for collaboration among team members
and generally a drag to work with.

Xcode 项目是单一的、脆弱的和不透明的。它们是团队成员合作时摩擦的来源，也常常是工作的累赘。

Fortunately,
`xcconfig` files go a long way to address these pain points.
Moving configuration out of Xcode and into `xcconfig` files
confers a multitude of benefits
and offers a way to distance your project from the particulars of Xcode
without leaving the Cupertino-approved "happy path".

幸运的是，`xcconfig` 文件很好地解决了这些痛点。将配置从 Xcode 移到 `xcconfig` 文件带来了很多好处，可以让你的项目与 Xcode 的细节保持一定距离，不受苹果公司的掣肘。
