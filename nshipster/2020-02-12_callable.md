title: "Swift 中的静态和动态可调用类型"
date: 2020-02-12
tags: [Swift, NSHipster]
categories: [Swift, NSHipster]
permalink: nshipster-callable

---
原文链接=https://nshipster.com/callable/
作者=Mattt
原文日期=2020-02-12
译者=
校对=
定稿=

<!--此处开始正文-->

Last week,
Apple released the [first beta of Xcode 11.4][xcode 11.4 release notes],
and it's proving to be one of the most substantial updates in recent memory.
`XCTest` got [a huge boost][xcode 11.4 testing],
with numerous quality of life improvements,
and [Simulator][xcode 11.4 simulator], likewise, got a solid dose of
<abbr title="tender loving care">TLC</abbr>.
But it's the changes to Swift that are getting the lion's share of attention.

上一周，Apple 发布了 [Xcode 11.4 的第一个 beta 版本][https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes]，这个版本逐渐被证明是近来最实用的更新之一。`XCTest` 框架在使用体验上也有了 [一次巨大地提升][https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes#3530390]，[模拟器][https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes#3530393]同样也有实质性的提升。但实际上引发最大的关注的是 Swift 的变化。

<!--more-->

In Xcode 11.4,
Swift compile times are down across the board,
with many developers reporting improvements of 10 – 20% in their projects.
And thanks to a [new diagnostics architecture][https://swift.org/blog/new-diagnostic-arch-overview/],
error messages from the compiler are consistently more helpful.
This is also the first version of Xcode to ship with the new
[`sourcekit-lsp` server](/language-server-protocol/),
which serves to empower editors like [VSCode](/vscode/)
to work with Swift in a more meaningful way.

在 Xcode 11.4 中，Swift 编译时间不断减少，许多开发者表示他们项目的编译时间有了 10 - 20% 的提升。得益于[新的诊断机制][https://swift.org/blog/new-diagnostic-arch-overview/]，编译系统报出的错误信息变得更加有用。这也是 Xcode 第一次提供全新的 [`sourcekit-lsp` 服务器](/language-server-protocol/) ，它可以授权像 [VSCode](/vscode/) 这类编辑器来让其更好地兼容 Swift。

Yet,
despite all of these improvements
(which are truly an incredible achievement by Apple's Developer Tools team),
much of the early feedback has focused on
the most visible additions to Swift 5.2.
And the response from the peanut galleries of
Twitter, Hacker News, and Reddit has been —
to put it charitably — _"mixed"_.

但是，尽管 Xcode 有这么多方面的提升（这确实是属于苹果开发工具团队一项令人难以置信的成就），但从早期有较多的反馈来看，更多的是在关注 Swfit 5.2 上最亮眼的新增特性。并且来自 Twitter、Hacker News 和 Reddit 各个平台的意见都被 *“综合”* 起来考虑了。

* * *

If like most of us,
you aren't tuned into the comings-and-goings of [Swift Evolution][swift evolution],
Xcode 11.4 was your first exposure to two new additions to the language:
[key path expressions as functions][se-0249] 
and
[callable values of user-defined nominal types][se-0253].

The first of these allows key paths to replace
one-off closures used by functions like `map`:

```swift
// Swift >= 5.2
"🧁🍭🍦".unicodeScalars.map(\.properties.name)
// ["CUPCAKE", "LOLLIPOP", "SOFT ICE CREAM"]

// Swift <5.2 equivalent
"🧁🍭🍦".unicodeScalars.map { $0.properties.name }
```

如果你跟我们大多数人一样，没能适应快速的 [Swift 迭代][https://apple.github.io/swift-evolution/]，Xcode 11.4 是你第一次接触到 Swift 的两个新特性：[可作为函数的关键路径表达式][https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md] 和 [自定义类型的可调用值][https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md]。

其中第一种特性的作用是，可以让关键路径用函数替换一次性闭包，例如 `map` 函数：

```swift
// Swift >= 5.2
"🧁🍭🍦".unicodeScalars.map(\.properties.name)
// ["CUPCAKE", "LOLLIPOP", "SOFT ICE CREAM"]

// Swift 版本 <5.2 的等效做法
"🧁🍭🍦".unicodeScalars.map { $0.properties.name }


The second allows instances of types with a method named `callAsFunction`
to be called as if they were a function:

```swift
struct Sweetener {
    let additives: Set<Character>

    init<S>(_ sequence: S) where S: Sequence, S.Element == Character {
        self.additives = Set(sequence)
    }

    func callAsFunction(_ message: String) -> String {
        message.split(separator: " ")
               .flatMap { [$0, "\(additives.randomElement()!)"] }
               .joined(separator: " ") + "😋"
    }
}

let dessertify = Sweetener("🧁🍭🍦")
dessertify("Hello, world!")
// "Hello, 🍭 world! 🍦😋"
```

第二种特性可以让带有 `callAsFunction` 函数的类型实例，作为一个函数被调用：

```swift
struct Sweetener {
    let additives: Set<Character>

    init<S>(_ sequence: S) where S: Sequence, S.Element == Character {
        self.additives = Set(sequence)
    }

    func callAsFunction(_ message: String) -> String {
        message.split(separator: " ")
               .flatMap { [$0, "\(additives.randomElement()!)"] }
               .joined(separator: " ") + "😋"
    }
}

let dessertify = Sweetener("🧁🍭🍦")
dessertify("Hello, world!")
// "Hello, 🍭 world! 🍦😋"
```

* * *

Granted,
both of those examples are terrible.
And that's kinda the problem.

* * *

* * *

当然，这两个例子中的特性并没多好，但他们也正是问题所在。

* * *

Too often,
coverage of _"What's New In Swift"_
amounts to little more than a regurgitation（回流） of Swift Evolution proposals（建议）,
interspersed with poorly motivated (and often emoji-laden) examples.
Such treatments provide a poor characterization of Swift language features,
and — in the case of Swift 5.2 —
serves to feed into the popular critique（临界） that these are frivolous（无聊的） additions ---
mere <dfn>[syntactic sugar][syntactic sugar]</dfn>.

很多时候，很多关于 _"Swift 新特性"_ 的报导并不是介绍新的特性，而是在对 Swift 迭代建议的反馈，并且会带着一些让人提不兴趣（经常填满 emoji 表情）的示例。这类做法导致 Swift 语言特性的风评变差。像 Swift 5.2 版本，舆论就会因此发酵成说这些新特性不过是没用的附加功能 —— 就是语法糖 [https://en.wikipedia.org/wiki/Syntactic_sugar]。


To the extent that we've been guilty of that...
our bad <span lang="und-Zsye">🙇‍♂️</span>.

某种程度上说，我们难辞其咎... 我们错了 🙇‍♂。

This week,
we hope to reach the ooey gooey center of the issue
by providing some historical and theoretical context
for understanding these new features.

在这一周，我们希望能找到问题的关键所在，以一些历史和理论背景来解读这些新特性。

## Syntactic Sugar in Swift

If you're salty about "key path as function" being too sugary,
recall that the <span lang="la">status quo</span>
isn't without a sweet tooth.
Consider our saccharine example from before:

```swift
"🧁🍭🍦".unicodeScalars.map { $0.properties.name }
```

## Swift 语法糖

你可能不想见到 “关键路径式函数” 过于往语法糖的方向发展，但现在已经有不少语法糖的应用场景了。回想下之前我们用到语法糖的那个例子：

```swift
"🧁🍭🍦".unicodeScalars.map { $0.properties.name }
```

That expression relies on at least four different syntactic concessions:

1. **Trailing closure syntax**,
   which allows a final closure argument label of a function to be omitted
2. **Anonymous closure arguments**,
   which allow arguments in closures to be used positionally (`$0`, `$1`, ...)
   without binding to a named variable.
3. **Inferred parameter and return value types**
4. **Implicit return from single-expression closures** 

If you wanted to cut sugar out of your diet completely,
you'd best get [Mavis Beacon][mavis beacon teaches typing] on the line,
because you'll be doing a lot more [typing](/rawrepresentable/).

```swift
"🧁🍭🍦".unicodeScalars.map(transform: { (unicodeScalar: Unicode.Scalar) -> String in
    return unicodeScalar.properties.name
})
```

<aside class="parenthetical">

Also, who knew that the argument label in `map` was "transform"?

</aside>

这句表达式用到了四种不同的语法技巧：

1. **尾随闭包** 允许最后一个参数标记被省略。
2. **匿名闭包参数** 是一种在闭包中的参数（$0，$1，……）根据位置来使用，而且不用给参数绑定命好名的变量。
3. 推断参数和返回值类型。
4. 单表达式闭包的隐式返回。

要是你想在工作中戒掉“糖”，那你最好让 [Mavis Beacon][https://en.wikipedia.org/wiki/Mavis_Beacon_Teaches_Typing] 来在线帮你打字，因为你将会需要打很多字。

```swift
"🧁🍭🍦".unicodeScalars.map(transform: { (unicodeScalar: Unicode.Scalar) -> String in
    return unicodeScalar.properties.name
})
```

> 对了，有谁知道 `map` 里的参数标记是 “transform”？

In fact,
as we'll see in the examples to come,
Swift is a marshmallow world in the winter,
_syntactically speaking_.
From initializers and method calls to optionals and method chaining,
nearly everything about Swift could be described as a cotton candy melody —
it really just depends on where you draw the line between
"language feature" and "syntactic sugar".

其实，正如我们接下来的例子，Swift *从句法上讲* 就是冬天里一个充满棉花糖的世界。从初始化构造器和方法调用岛可选值和链式方法调用，几乎所有关于 Swift 的事情都能看到语法糖的影子——就看你是如何划分“语言特性”和“语法糖”。

* * *

To understand why,
you have to understand how we got here in the first place,
which requires a bit of history, math, and computer science.
Get ready to eat your vegetables 🥦.

要理解其中原因，你首先要弄明白事情的由来，这里要用到一点历史、数学和计算机科学的知识。做好准备来享用吧。

## The λ-Calculus and Speculative Computer Science Fiction

## λ-演算和计算机科幻推理小说

All programming languages can be seen as various attempts to represent
[the <abbr lang="la" title="lambda">λ</abbr>-calculus][lambda calculus].
Everything you need to write code —
variables, binding, application —
it's all in there,
buried under a mass of Greek letters and mathematical notation.

所有的编程语言都可以看作是对 [λ演算][https://en.wikipedia.org/wiki/Lambda_calculus] 的各种演绎尝试。所有你要用代码编写的地方 —— 变量、绑定、应用 - 在里面都有体现，被大量希腊字母和数学符号掩埋着。

Setting aside syntactic differences,
each programming language can be understood by
its combination of affordances for
making programs easier to write and easier to read.
Language features like
objects,
classes,
modules,
optionals,
literals,
and generics
are all just abstractions built on top of the λ-calculus.

如果抛开语法的差异，每门编程语言都可以通过功能特性的组合来理解，以使程序更容易编写和阅读。像对象、类、模块、可选值、字面量和泛型等语言特性都是建立在λ演算上对其特性的抽象.

Any other deviation from pure mathematical formalism
can be ascribed to real-world constraints,
such as
[a typewriter from the 1870s][qwerty],
[a punch card from the 1920s][punch cards],
[a computer architecture from the 1940s][von neumann],
or [a character encoding from the 1960s][ascii].

任何编程和纯数学形式主义存在的偏差，都可以归因于现实世界的约束，例如 [19 世纪 70 年代的打字机][https://en.wikipedia.org/wiki/QWERTY]、[20 世纪 20 年代的穿孔卡片][https://en.wikipedia.org/wiki/Punched_card#IBM_80-column_punched_card_format_and_character_codes]、[40 年代的计算机体系结构][https://en.wikipedia.org/wiki/Von_Neumann_architecture] 或 [60 年代的字符编码][https://en.wikipedia.org/wiki/ASCII]。

Among the earliest programming languages were Lisp, ALGOL*, and COBOL,
from which nearly every other language derives.

最早的编程语言包括 Lisp、ALGOL*和 COBOL，其他编程语言几乎都是从这些语言派生出来的。

<aside clasS="parenthetical">

We're using FORTRAN as a stand-in here,
for lack of an easily-accessible ALGOL environment.

</aside>

> 由于没有方便的 ALGOL 访问环境，我们在这里用 FORTRAN 代替。


```lisp
(defun square (x)
    (* x x))

(print (square 4)) 
;; 16
```

```fortran
pure function square(x)
  integer, intent(in) :: x
  integer :: square
  square = x * x
end function

program main
  integer :: square
  print *, square(4)
end program main
! 16
```

```cobol
IDENTIFICATION DIVISION.
       PROGRAM-ID. example.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01  x   PIC 9(3) VALUE 4.
       01  y   PIC 9(9).
       PROCEDURE DIVISION.
           CALL "square" USING
               BY CONTENT x
               BY REFERENCE y.
           DISPLAY y.
           STOP RUN.
       END PROGRAM example.

IDENTIFICATION DIVISION.
       PROGRAM-ID. square.
       DATA DIVISION.
       LINKAGE SECTION.
       01  x   PIC 9(3).
       01  y   PIC 9(3).
       PROCEDURE DIVISION USING x, y.
           MULTIPLY x BY x GIVING y.
           EXIT PROGRAM.
       END PROGRAM square.
* 016000000
```

Here you get a glimpse into three very different timelines;
ours is the reality in which ALGOL's syntax (option #2)
"won out" over the alternatives.
From ALGOL 60,
you can draw a straight line from
[CPL][cpl] in 1963,
to [BCPL][bcpl] in 1967
and [C] in 1972,
followed by [Objective-C in 1984](/direct/#object-oriented-programming)
and Swift in 2014.
That's the lineage that informs what types are callable and how we call them.

* * *

这里，你看到了 3 种不同时间线的版本；我们当下的这一种是 ALGOL 的语法（第二项），它“赢过”了另外两个选项。你可以自 ALGOL 60 开始追溯起，从 1963 年的 [CPL][https://en.wikipedia.org/wiki/CPL_(programming_language)] 到 1967 年的 [BCPL][https://en.wikipedia.org/wiki/BCPL] 和 1972 年的 [C][https://en.wikipedia.org/wiki/C_(programming_language)]，再之后的 [Objective-C in 1984](/direct/#object-oriented-programming) 和 2014 的 Swift。这就是可调用类型及其调用方法的沿袭历史。

* * *

_Now, back to Swift..._

_现在，回到 Swift……_

## Function Types in Swift

Functions are first-class objects in Swift,
meaning that they can be assigned to variables,
stored in properties,
and passed as arguments or returned as values from other functions.

What distinguishes function types from other values
is that they're <dfn>callable</dfn>,
meaning that you can invoke them to produce new values.

## Swift 中的函数类型

函数是 Swift 中的第一类对象，这意味着它们可以赋值给变量、存储属性、当参数传递或者作为其它函数的返回值。

函数类型和其它类型的区别是在于它们可以被调用，也就是说你可以调用他它来生成新的值。

### Closures

Swift's fundamental function type is the <dfn>closure</dfn>,
a self-contained unit of functionality.

```swift
let square: (Int) -> Int = { x in x * x }
```

### 闭包

Swift 中的基本函数类型是 *闭包*，它是一个功能独立的单元。

```swift
let square: (Int) -> Int = { x in x * x }
```

As a function type,
you can call a closure by passing the requisite number of arguments
between opening and closing parentheses `()` —
<em lang="fr">a la</em> ALGOL.

```swift
square(4) // 16
```

作为函数类型，你可以通过传递左、右括号中指定数量的参数来调用闭包——依照 ALGOL。

```swift
square(4) // 16
```

{% info %}

The number of arguments taken by a function type
is known as its <dfn>arity</dfn>.

{% endinfo %}

> 一个函数所能接收的参数数量就是它的 *参数个数*。

Closures are so called because they <dfn>close over</dfn> and capture
references to any variables from the context in which they're defined.
However, capturing semantics aren't always desirable,
which is why Swift provides dedicated syntax to a special kind of closure
known as a <dfn>function</dfn>.

闭包之所以成为闭包，是因为它们是完整闭合的，可以在其定义的上下文中捕获到变量的引用。但这种捕获语义并不总是满足编程需求求，所以 Swift 提供了专门语法来表示一种可以做为 *函数* 的特殊闭包。 

### Functions

Functions defined at a top-level / global scope
are named closures that don't capture any values.
In Swift,
you declare them with the `func` keyword:

```swift
func square(_ x: Int) -> Int { x * x }
square(4) // 16
```

### 函数

在顶层/全局范围定义的函数是就种不会捕获任何值的闭包。在 Swift 中，你可以用关键字 `func` 来进行申明。

```swift
func square(_ x: Int) -> Int { x * x }
square(4) // 16
```

Compared to closures,
functions have greater flexibility in how arguments are passed.

Function arguments can have named labels
instead of a closure's unlabeled, positional arguments —
which goes a long way to clarify the effect of code at its call site:

```swift
func deposit(amount: Decimal,
             from source: Account,
             to destination: Account) throws { <#...#> }
try deposit(amount: 1000.00, from: checking, to: savings)
```

和闭包相比，函数在值的传递上有很大的灵活性。

函数参数可以有命名标签，不像闭包是无法定义标签的位置参数 —— 这种命名标签很好的阐明了代码的作用。

```swift
func deposit(amount: Decimal,
             from source: Account,
             to destination: Account) throws { <#...#> }
try deposit(amount: 1000.00, from: checking, to: savings)
```

Functions can be [generic][generics],
allowing them to be used for multiple types of arguments:

```swift
func square<T: Numeric>(_ x: T) -> T { x * x }
func increment<T: Numeric>(_ x: T) -> T { x + 1 }
func compose<T>(_ f: @escaping (T) -> T, _ g: @escaping (T) -> T) -> (T) -> T {
    { x in g(f(x)) }
}

compose(increment, square)(4 as Int) // 25 ((4 + 1)²)
compose(increment, square)(4.2 as Double) // 27.04 ((4.2 + 1)²)
```

函数可以以 [泛型][https://docs.swift.org/swift-book/LanguageGuide/Generics.html] 形式存在，用于充当各种类型的参数。
```swift
func square<T: Numeric>(_ x: T) -> T { x * x }
func increment<T: Numeric>(_ x: T) -> T { x + 1 }
func compose<T>(_ f: @escaping (T) -> T, _ g: @escaping (T) -> T) -> (T) -> T {
    { x in g(f(x)) }
}

compose(increment, square)(4 as Int) // 25 ((4 + 1)²)
compose(increment, square)(4.2 as Double) // 27.04 ((4.2 + 1)²)
```

Functions can also take variadic arguments,
implicit closures,
and default argument values
(allowing for magic expression literals like `#file` and `#line`):

```swift
func print(items: Any...) { <#...#> }

func assert(_ condition: @autoclosure () -> Bool,
            _ message: @autoclosure () -> String = String(),
            file: StaticString = #file,
            line: UInt = #line) { <#...#> }
```

函数还能接收可变参数、隐式闭包和默认参数值（允许使用像 `#file` 和 `#line` 这样的特殊编译符号）：

```swift
func print(items: Any...) { <#...#> }

func assert(_ condition: @autoclosure () -> Bool,
            _ message: @autoclosure () -> String = String(),
            file: StaticString = #file,
            line: UInt = #line) { <#...#> }
```

And yet,
despite all of this flexibility for accepting arguments,
most functions you'll encounter operate on an _implicit_ `self` argument.
These functions are called methods.

然而，尽管函数在参数接收上很高的灵活性，但你遇到的大多数函数都基于一个 *隐式* 的 `self` 参数操作的。这些函数就被称作方法。

### Methods

A <dfn>method</dfn> is a function contained by a type.
Methods automatically provide access to `self`,
allowing them to effectively capture the instance on which they're called
as an implicit argument.

```swift
struct Queue<Element> {
    private var elements: [Element] = []

    mutating func push(_ newElement: Element) {
        self.elements.append(newElement)
    }

    mutating func pop() -> Element? {
        guard !self.elements.isEmpty else { return nil }
        return self.elements.removeFirst()
    }
}
```

### 方法

*方法* 就是一个被各种类型包含着的函数。方法自动提供了对 `self` 的调用，可以让它们有效地捕获实例作为隐式参数调用。

{% info %}

Swift goes one step further
by allowing `self.` to be omitted for member access —
making the already implicit `self` all the more implicit.

{% endinfo %}

> Swift 更进一步允许内部成员在调用时省略 `self.` —— 使得本已是隐式的 `self` 更加隐密。

* * *

Putting everything together,
these syntactic affordances allow Swift code to be
expressive, clear, and concise:

```swift
var queue = Queue<Int>()
queue.push(1)
queue.push(2)
queue.pop() // 1
```

总的来说，这些语法特性让 Swift 代码变得更具表现力、清晰和简洁：

```swift
var queue = Queue<Int>()
queue.push(1)
queue.push(2)
queue.pop() // 1
```

Compared to more verbose languages like Objective-C,
the experience of writing Swift is, well, pretty _sweet_.
It's hard to imagine any Swift developers objecting to what we have here 
as being "sugar-coated".

But like a 16oz can of [Surge][surge],
the sugar content of something is often surprising.
Turns out, 
that example from before is far from innocent:

```swift
var queue = Queue<Int>() // desugars to `Queue<Int>.init()`
queue.push(1) // desugars to `Queue.push(&queue)(1)`
```

和 Objective-C 这样过于冗长的语言相比，编写 Swift 的过程很 *美好*。很懵懂想象有 Swift 开发会反对我们这里的 "糖衣炮弹"。

但就像一罐 16 盎司的 [Surge][https://en.wikipedia.org/wiki/Surge_(drink)]，里面的含糖量往往令人震惊。所以实际上，上面的例子并不是那么简单：

```swift
var queue = Queue<Int>() // 不用语法糖的话则是 `Queue<Int>.init()`
queue.push(1) // 不用语法糖的话则是 `Queue.push(&queue)(1)`
```

All this time,
our so-called "direct" calls to methods and initializers
were actually shorthand for <del>[function currying][currying]</del>
<ins>[partially-applied functions][partial application]</ins>.

一直以来，我们对方法和初始化构造器的“直接”调用，其实是 ～～[柯里化函数][https://en.wikipedia.org/wiki/Currying]～～ [偏函数应用][https://en.wikipedia.org/wiki/Partial_application] 的简写。

{% info %}

Partial application and currying are often conflated.
In fact, 
[they're distinct but related concepts](https://ericasadun.com/2017/04/03/musings-on-partial-application/).

Early versions of Swift had a dedicated syntax for currying functions,
but it proved less useful than originally anticipated
and was removed by the [second-ever Swift Evolution proposal][se-0002].

```swift
// Swift <3:
func curried(x: Int)(y: String) -> Float {
    return Float(x) + Float(y)!
}

// Swift >=3
func curried(x: Int) -> (String) -> Float {
    return { (y: String) -> Float in
        return Float(x) + Float(y)!
    }
}
```

{% endinfo %}

> 偏函数应用和柯里化经常被混为一谈。[它们形式上虽有所区别，但理念上有类似的地方](https://ericasadun.com/2017/04/03/musings-on-partial-application/)。早起版本的 Swift 有专门的柯里化函数，但是实际上没有原先预料的那样有用，在[第二次版本迭代][https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md]的时候就被移除了。

```swift
// Swift <3:
func curried(x: Int)(y: String) -> Float {
    return Float(x) + Float(y)!
}

// Swift >=3
func curried(x: Int) -> (String) -> Float {
    return { (y: String) -> Float in
        return Float(x) + Float(y)!
    }
}
```

With this in mind,
let's now take another look at callable types in Swift more generally.

## {Type, Instance, Member} ⨯ {Static, Dynamic}

考虑到这一点，现在让我们看下在 Swift 中更加普遍的可调用类型。

## {Type, Instance, Member} ⨯ {Static, Dynamic}

Since their introduction in Swift 4.2 and Swift 5, respectively,
many developers have had a hard time keeping
`@dynamicMemberLookup` and `@dynamicCallable`
straight in their minds —
made even more difficult by the introduction of `callAsFunction` in Swift 5.2.

自从它们分别从 Swift 4.2 和 Swift 5 引入以来，许多开发人员很难在面对 `@dynamicMemberLookup` 和 `@dynamicCallable` 时保持头脑清晰——在 Swift 5.2 中引入 `callAsFunction` 后，就变得更难了。

If you're also confused,
we think the following table can help clear things up:

|             | Static               | Dynamic                    |
|-------------|----------------------|----------------------------|
| Type        | `init`               | _N/A_                      |
| Instance    | **`callAsFunction`** | **`@dynamicCallable`**     |
| Member      | `func`               | **`@dynamicMemberLookup`** |

如果你也觉得困惑，下面的表格应该可以帮你梳理清楚：

|             | Static               | Dynamic                    |
|-------------|----------------------|----------------------------|
| Type        | `init`               | _N/A_                      |
| Instance    | **`callAsFunction`** | **`@dynamicCallable`**     |
| Member      | `func`               | **`@dynamicMemberLookup`** |


Swift has always had static callable types and type members.
What's changed in new versions of Swift
is that instances are now callable,
and both instances and members can now be called dynamically.

Swift 一直都有静态可调用类型和类型成员。新版本的 Swift 中实例变成可调用类型，实例和成员现在均可以被调用了。

{% warning %}

You might have noticed the blank spot in our table.
Indeed, there's no way to dynamically call types.
In fact, there's no way to statically call types
other than to invoke initializers —
and that's probably for the best.

{% endwarning %}

> 你可能注意到我们表格里的空内容处了。实际上，我们是没办法动态地去调用类型。除了在初始化构造器内部调用，是没有其他方法静态地调用类型——这也许才是最合理的设计。
 
Let's see what that means in practice,
starting with static callables.

### Static Callable

```swift
struct Static {
    init() {}

    func callAsFunction() {}

    static func function() {}
    func function() {}
}
```

让我们从静态可调用类型开始看下，这样设计实际上意味着什么。

### 静态可调用类型

```swift
struct Static {
    init() {}

    func callAsFunction() {}

    static func function() {}
    func function() {}
}
```

This type can be called statically in the following ways:

```swift
let instance = Static() // <#❶#> desugars to `Static.init()`

Static.function() // <#❷#> (no syntactic sugar!)
instance.function() // <#❸#> desugars to Static.function(instance)()

instance() // <#❹#> desugars to `Static.callAsFunction(instance)()`
```

这个类型可以用下面的方式来静态调用：

```swift
let instance = Static() // <#❶#> 不用语法糖的话则是 `Static.init()`

Static.function() // <#❷#> （没有语法糖!）
instance.function() // <#❸#> 不用语法糖的话则是 Static.function(instance)()

instance() // <#❹#> 不用语法糖的话则是 `Static.callAsFunction(instance)()`
```

❶
: Calling the `Static` type invokes an initializer

❷ 
: Calling `function` on the `Static` type
  invokes the corresponding static function member,
  passing `Static` as an implicit `self` argument.

❸
: Calling `function` on an instance of `Static`
  invokes the corresponding function member,
  passing the instance as an implicit `self` argument.

❹
: Calling an instance of `Static`
  invokes the `callAsFunction()` function member,
  passing the instance as an implicit `self` argument.

❶
: 通过 `Static` 类型调用初始化构造器。

❷ 
: 通过 `Static` 类型的 `function` 函数，将实例作为一个隐式的 `self` 参数，进而调用相应的静态函数成员。

❸
: 通过一个 `Static` 实例的 `function` 函数，将实例作为一个隐式的 `self` 参数，进而调用相应的静态函数成员。

❹
: 通过一个 `Static` 实例的 `function` 函数，将实例作为一个隐式的 `self` 参数，进而调用 `callAsFunction()` 这个函数成员。

{% info %}

A few points for completeness' sake:

- You can also statically call subscripts and variable members (properties).
- Operators provide an alternative way to invoke static member functions.
- Enumeration cases are, well... 
  something else entirely.

<!-- Interestingly,
     [a draft proposal](https://forums.swift.org/t/enum-cases-as-protocol-witnesses/32753/19)
     to allow enumeration cases to be treated as protocol witnesses
     is currently making the rounds on the Swift forums. -->

{% endinfo %}

> 为完整起见，还有几点需要注意：

- 你仍可以静态地调用下标和变量成员（属性）。
- 运算符可以作为调用静态函数成员的另一种方法。
- 而且枚举类型的枚举项也……，好吧，完全是另外一回事。


### Dynamic Callable

```swift
@dynamicCallable
@dynamicMemberLookup
struct Dynamic {
    func dynamicallyCall(withArguments args: [Int]) -> Void { () }
    func dynamicallyCall(withKeywordArguments args: KeyValuePairs<String, Int>) -> Void { () }

    static subscript(dynamicMember member: String) -> (Int) -> Void { { _ in } }
    subscript(dynamicMember member: String) -> (Int) -> Void { { _ in } }
}
```

### 动态可调用类型

```swift
@dynamicCallable
@dynamicMemberLookup
struct Dynamic {
    func dynamicallyCall(withArguments args: [Int]) -> Void { () }
    func dynamicallyCall(withKeywordArguments args: KeyValuePairs<String, Int>) -> Void { () }

    static subscript(dynamicMember member: String) -> (Int) -> Void { { _ in } }
    subscript(dynamicMember member: String) -> (Int) -> Void { { _ in } }
}
```

This type can be called dynamically in a few different ways:

```swift
let instance = Dynamic() // desugars to `Dynamic.init()`

instance(1) // <#❶#> desugars to `Dynamic.dynamicallyCall(instance)(withArguments: [1])`
instance(a: 1) // <#❷#> desugars to `Dynamic.dynamicallyCall(instance)(withKeywordArguments: ["a": 1])`

Dynamic.function(1) // <#❸#> desugars to `Dynamic[dynamicMember: "function"](1)`
instance.function(1) // <#❹#> desugars to `instance[dynamicMember: "function"](1)`
```

这个类型可以通过少数的几种方法来进行动态调用：

```swift
let instance = Dynamic() // 不用语法糖的话则是 `Dynamic.init()`

instance(1) // <#❶#> 不用语法糖的话则是 `Dynamic.dynamicallyCall(instance)(withArguments: [1])`
instance(a: 1) // <#❷#> 不用语法糖的话则是 `Dynamic.dynamicallyCall(instance)(withKeywordArguments: ["a": 1])`

Dynamic.function(1) // <#❸#> 不用语法糖的话则是 `Dynamic[dynamicMember: "function"](1)`
instance.function(1) // <#❹#> 不用语法糖的话则是 `instance[dynamicMember: "function"](1)`
```

❶
: Calling an instance of `Dynamic`
  invokes the `dynamicallyCall(withArguments:)` method,
  passing an array of arguments
  and `Dynamic` as an implicit `self` argument.

❷
: Calling an instance of `Dynamic`
  with at least one labeled argument
  invokes the `dynamicallyCall(withKeywordArguments:)` method,
  passing the arguments in a [`KeyValuePairs` object](/keyvaluepairs/)
  and `Dynamic` as an implicit `self` argument.

❸
: Calling `function` on the `Dynamic` type
  invokes the static `dynamicMember` subscript,
  passing `"function"` as the key;
  here, we call the returned anonymous closure.

❹
: Calling `function` on an instance of `Dynamic`
  invokes the `dynamicMember` subscript,
  passing `"function"` as the key;
  here, we call the returned anonymous closure.
  
❶
: 通过一个 `Static` 实例，传入一个数组作为参数的同时，将 `Dynamic` 作为一个隐式的 `self` 参数来调用 `dynamicallyCall(withArguments:)` 方法。

❷
: 通过带有至少一个标签参数的 `Dynamic` 实例，传入 [`键值对` 对象](/keyvaluepairs/) 作为参数的同时，将 `Dynamic` 作为一个隐式的 `self` 参数来调用 `dynamicallyCall(withKeywordArguments:)` 方法。

❸
: 通过 `Static` 类型的 `function` 函数，把 `"function"` 作为一个键传入，来调用静态的 `dynamicMember` 下标；这里我们把返回值称作是匿名闭包。

❹
: 通过一个 `Static` 实例的 `function` 函数，把 `"function"` 作为一个键传入，来调用 `dynamicMember` 下标；这里我们把返回值称作是匿名闭包。

#### Dynamism by Declaration Attributes

`@dynamicCallable` and `@dynamicMemberLookup`
are declaration attributes,
which means that they can't be applied to existing declarations
through an extension.

#### 声明式属性的动态性

`@dynamicCallable` 和 `@dynamicMemberLookup` 是声明式属性，意味着它们不能通过扩展去应用于已存在的声明。

So you can't, for example,
_spice up_ `Int` with [Ruby-ish][rails core_ext array]
natural language accessors:

```swift
@dynamicMemberLookup // ⚠︎ Error: '@dynamicMemberLookup' attribute cannot be applied to this declaration
extension Int {
    static subscript(dynamicMember member: String) -> Int? {
        let string = member.replacingOccurrences(of: "_", with: "-")

        let formatter = NumberFormatter()
        formatter.numberStyle = .spellOut
        return formatter.number(from: string)?.intValue
    }
}

// ⚠︎ Error: Just to be super clear, this doesn't work
Int.forty_two // 42 (hypothetically, if we could apply `@dynamicMemberLookup` in an extension)
```

就像是你无法用 [Ruby 式][https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/array/access.r] 自然语言访问器描述 `Int`：

```swift
@dynamicMemberLookup // ⚠︎ Error: '@dynamicMemberLookup' 属性不能应用到这个声明
extension Int {
    static subscript(dynamicMember member: String) -> Int? {
        let string = member.replacingOccurrences(of: "_", with: "-")

        let formatter = NumberFormatter()
        formatter.numberStyle = .spellOut
        return formatter.number(from: string)?.intValue
    }
}

// ⚠︎ Error: 上面代码只是为了展示清楚，实际上是无法运行的
Int.forty_two // 42（假设我们可以在扩展上用 `@dynamicMemberLookup`）
```

Contrast this with `callAsFunction`,
which can be added to any type in an extension.

用 `callAsFunction` 和它相比，`callAsFunction` 可以添加到扩展中的任何类型。

{% info %}

For more information about these new language features,
check out the original Swift Evolution proposals:

- [SE-0195: Introduce User-defined "Dynamic Member Lookup" Types][https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md]
- [SE-0216: Introduce - user-defined dynamically "callable" types][https://github.com/apple/swift-evolution/blob/master/proposals/0216-dynamic-callable.md]
- [SE-0249: Key Path Expressions as Functions][se-0249]
- [SE-0252: Key - Path Member Lookup][se-0252]
- [SE-0253: Callable values of user-defined nominal types][se-0253]

{% endinfo %}

> 想了解更多关于这个新语言特性的信息，请查看 Swift Evolution 的原始提案

- [SE-0195：介绍用户定义的“动态成员查找”类型][https://github.com/apple/swift-evolution/blob/master/proposals/
- [SE-0216：介绍 - 用户定义的动态“可调用”类型][https://github.com/apple/swift-evolution/blob/master/proposals/0216-dynamic-callable.md]
- [SE-0249：键路径表达式函数][https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md]
- [SE-0252：键 - 路径成员查找][https://github.com/apple/swift-evolution/blob/master/proposals/0252-keypath-dynamic-member-lookup.md]
- [SE-0253：用户定义的名义类型可调用值][https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md]

* * *

There's much more to talk about with
`@dynamicMemberLookup`, `@dynamicCallable`, and `callAsFunction`,
and we look forward to covering them all in more detail
in future articles.

* * *

* * *

关于 `@dynamicMemberLookup`、`@dynamicCallable` 和 `callAsFunction` 还有很多要讨论的地方，我们希望能在以后的文章中更详细地介绍它们。

* * *

_But speaking of <del>Ruby</del><ins>Python</ins>..._

*但说到 ~~Ruby~~ Python 就……*

## Swift ⨯ ___________________

## Swift ⨯ ___________________

Adding to
[our list of _"What code is like"_](/numericcast/):

> Code is like fan fiction.

添加到 [我们的 *“代码是什么"* 目录] (/numericcast/)：

> 代码就像是同人小说

Sometimes to ship software,
you need to pair up and "ship" different technologies.

有时候发布软件，你需要成套发布，并且“推出”不同的技术。

<aside class="parenthetical">

In a way,
the story of Swift is one of the great, tragic romances in modern computing;
how else might we describe the way
Objective-C sacrificed itself to make Swift possible?

</aside>

> 某种程度上来说，Swift 的故事是现代计算机技术中最伟大的悲剧之一；否则我们要来如何描述 Objective-C 为成就 Swift 而牺牲自己的方式呢？

In building these features,
the "powers that be" have ordained that
[Swift replace Python for Machine Learning][s4tf].
Taking for granted that an incremental approach is best,
the way to make that happen is to allow
Swift to interoperate with Python
as seamlessly as it does with Objective-C.
And since Swift 4.2,
we've been [getting pretty close][python interop].

```swift
import Python

let numpy = Python.import("numpy")
let zeros = numpy.ones([2, 4])
/* [[1, 1, 1, 1]
    [1, 1, 1, 1]] */
```

在构建这些特性的过程中，“当权者”已经决定让 [Swift 取代 Python 进行机器学习][https://github.com/tensorflow/swift/blob/master/docs/WhySwiftForTensorFlow.md]。当然，最好还是一步步来，实现方法就是允许 Swift 和 Python 能无缝交互，就像它和 Objective-C 一样。从 Swift 4.2 开始，我们离这个目标已经 [相当近][https://www.tensorflow.org/swift/tutorials/python_interoperability] s了。

```swift
import Python

let numpy = Python.import("numpy")
let zeros = numpy.ones([2, 4])
/* [[1, 1, 1, 1]
    [1, 1, 1, 1]] */
```

## The Externalities of Dynamism

The promise of additive changes is that they don't change anything
if you don't want them to.
You can continue to write Swift code
remaining totally ignorant of the features described in this article
(most of us have so far).
But let's be clear:
there are no cost-free abstractions.

## 动态性的外部效应

这个附加特性的前提是保证如果你不想要这些特性，他们不会对任何东西造成改变。你可以继续写 Swift 代码，继续完全忽略本文提到的特性（到目前为止我们都是如此）。但我们应该知道：没有免费的抽象。

Economics uses the term [<dfn>negative externalities</dfn>][externality]
to describe indirect costs incurred by a decision.
Although you don't pay for these features unless you use them,
we all shoulder the burden of a more complex language
that's more difficult to teach, learn, document, and reason about.

经济学用 [*负外部性*][https://en.wikipedia.org/wiki/Externality] 来描述决策所产生的间接成本。尽管除非你使用这些功能，否则你不会为此付出什么，我们都肩负着一门更复杂的语言的重担，这门语言更难教、更难学、更难记录、更难思考。

* * *

A lot of us who have been with Swift from the beginning
have grown weary of Swift Evolution.
And for those on the outside looking in,
it's unfathomable that we're wasting time on inconsequential "sugar" like this
instead of features that will _really_ move the needle,
like [`async` / `await`][async await].

我们很多从一开始就接触 Swift 的人已经厌倦了 Swift 的迭代更新。对于那些持观望态度的人来说，我们的这种做法是很难让人理解的。他们认为我们就是浪费时间在这些无关紧要的“语法糖”，而不是像 [`async` / `await`][https://gist.github.com/lattner/429b9070918248274f25b714dcfc7619] 这样 *真正* 有用的功能。

In isolation,
each of these proposals is thoughtful and useful — _genuinely_.
We've already [had occasion][dbscan] to use a few of them.
But it can be really hard to judge things on their own technical merits
when they're steeped in emotional baggage.

单独来看，这些建议中每一个都是深思熟虑而且有用的 —— *真的*。我们已经 [有机会][https://github.com/NSHipster/DBSCAN] 可以用其中的一些特性了。但是当他们背负着感情包袱时，很难根据它们本身的技术优势对他们进行判断。

Everyone has their own sugar tolerance,
and it's often informed by what they're accustomed to.
Being cognizant of the [drawbridge effect][drawbridge effect],
I honestly can't tell if I'm out of touch,
or if it's [the children who are wrong][skinner]...

每个人对糖都有自己的接收程度，这通常是是由他们的习惯的东西决定的。但想到 [吊桥效应][https://en.wikipedia.org/wiki/Drawbridge_mentality]，我真的不知道是我脱节，还是说 [年轻人才是错的][https://knowyourmeme.com/memes/am-i-out-of-touch]……

[se-0002]: https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md "SE-0002: Removing currying func declaration syntax"
[se-0195]: https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md "SE-0195: Introduce User-defined \"Dynamic Member Lookup\" Types"
[se-0216]: https://github.com/apple/swift-evolution/blob/master/proposals/0216-dynamic-callable.md "SE-0216: Introduce user-defined dynamically \"callable\" types"
[se-0249]: https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md "SE-0249: Key Path Expressions as Functions"
[se-0252]: https://github.com/apple/swift-evolution/blob/master/proposals/0252-keypath-dynamic-member-lookup.md "SE-0252: Key Path Member Lookup"
[se-0253]: https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md "SE-0253: Callable values of user-defined nominal types"

[xcode 11.4 release notes]: https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes
[xcode 11.4 testing]: https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes#3530390
[xcode 11.4 simulator]: https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes#3530393

[new diagnostics architecture]: https://swift.org/blog/new-diagnostic-arch-overview/ "Swift.org - New Diagnostic Architecture Overview"
[swift evolution]: https://apple.github.io/swift-evolution/ "Swift Evolution Proposals Dashboard"
[syntactic sugar]: https://en.wikipedia.org/wiki/Syntactic_sugar
[church-turing thesis]: https://en.wikipedia.org/wiki/Church–Turing_thesis "Church–Turing Thesis"
[lambda calculus]: https://en.wikipedia.org/wiki/Lambda_calculus
**********
[qwerty]: https://en.wikipedia.org/wiki/QWERTY "QWERTY"
[punch cards]: https://en.wikipedia.org/wiki/Punched_card#IBM_80-column_punched_card_format_and_character_codes
[ascii]: https://en.wikipedia.org/wiki/ASCII
[von neumann]: https://en.wikipedia.org/wiki/Von_Neumann_architecture "Von Neumann Architecture"
[piet]: https://en.wikipedia.org/wiki/Esoteric_programming_language#Piet
[cpl]: https://en.wikipedia.org/wiki/CPL_(programming_language)
[bcpl]: https://en.wikipedia.org/wiki/BCPL 
[c]: https://en.wikipedia.org/wiki/C_(programming_language)
[currying]: https://en.wikipedia.org/wiki/Currying
[partial application]: https://en.wikipedia.org/wiki/Partial_application
[mavis beacon teaches typing]: https://en.wikipedia.org/wiki/Mavis_Beacon_Teaches_Typing "Mavis Beacon Teaches Typing"
[generics]: https://docs.swift.org/swift-book/LanguageGuide/Generics.html "The Swift Programming Language - Generics"
[surge]: https://en.wikipedia.org/wiki/Surge_(drink) "SURGE"
[rails core_ext array]: https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/array/access.r
[s4tf]: https://github.com/tensorflow/swift/blob/master/docs/WhySwiftForTensorFlow.md
[python interop]: https://www.tensorflow.org/swift/tutorials/python_interoperability
[externality]: https://en.wikipedia.org/wiki/Externality
[dynamic swift thread]: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160926/027337.html
[async await]: https://gist.github.com/lattner/429b9070918248274f25b714dcfc7619
[dbscan]: https://github.com/NSHipster/DBSCAN
[drawbridge effect]: https://en.wikipedia.org/wiki/Drawbridge_mentality
[skinner]: https://knowyourmeme.com/memes/am-i-out-of-touch

{% asset 'articles/callable.css' %}
