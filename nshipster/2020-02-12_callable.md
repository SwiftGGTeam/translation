title: "Swift ä¸­çš„é™æ€å’ŒåŠ¨æ€å¯è°ƒç”¨ç±»å‹"
date: 2020-02-12
tags: [Swift, NSHipster]
categories: [Swift, NSHipster]
permalink: nshipster-callable

---
åŸæ–‡é“¾æ¥=https://nshipster.com/callable/
ä½œè€…=Mattt
åŸæ–‡æ—¥æœŸ=2020-02-12
è¯‘è€…=
æ ¡å¯¹=
å®šç¨¿=

<!--æ­¤å¤„å¼€å§‹æ­£æ–‡-->

Last week,
Apple released the [first beta of Xcode 11.4][xcode 11.4 release notes],
and it's proving to be one of the most substantial updates in recent memory.
`XCTest` got [a huge boost][xcode 11.4 testing],
with numerous quality of life improvements,
and [Simulator][xcode 11.4 simulator], likewise, got a solid dose of
<abbr title="tender loving care">TLC</abbr>.
But it's the changes to Swift that are getting the lion's share of attention.

ä¸Šä¸€å‘¨ï¼ŒApple å‘å¸ƒäº† [Xcode 11.4 çš„ç¬¬ä¸€ä¸ª beta ç‰ˆæœ¬][https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes]ï¼Œè¿™ä¸ªç‰ˆæœ¬é€æ¸è¢«è¯æ˜æ˜¯è¿‘æ¥æœ€å®ç”¨çš„æ›´æ–°ä¹‹ä¸€ã€‚`XCTest` æ¡†æ¶åœ¨ä½¿ç”¨ä½“éªŒä¸Šä¹Ÿæœ‰äº† [ä¸€æ¬¡å·¨å¤§åœ°æå‡][https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes#3530390]ï¼Œ[æ¨¡æ‹Ÿå™¨][https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes#3530393]åŒæ ·ä¹Ÿæœ‰å®è´¨æ€§çš„æå‡ã€‚ä½†å®é™…ä¸Šå¼•å‘æœ€å¤§çš„å…³æ³¨çš„æ˜¯ Swift çš„å˜åŒ–ã€‚

<!--more-->

In Xcode 11.4,
Swift compile times are down across the board,
with many developers reporting improvements of 10 â€“ 20% in their projects.
And thanks to a [new diagnostics architecture][https://swift.org/blog/new-diagnostic-arch-overview/],
error messages from the compiler are consistently more helpful.
This is also the first version of Xcode to ship with the new
[`sourcekit-lsp` server](/language-server-protocol/),
which serves to empower editors like [VSCode](/vscode/)
to work with Swift in a more meaningful way.

åœ¨ Xcode 11.4 ä¸­ï¼ŒSwift ç¼–è¯‘æ—¶é—´ä¸æ–­å‡å°‘ï¼Œè®¸å¤šå¼€å‘è€…è¡¨ç¤ºä»–ä»¬é¡¹ç›®çš„ç¼–è¯‘æ—¶é—´æœ‰äº† 10 - 20% çš„æå‡ã€‚å¾—ç›Šäº[æ–°çš„è¯Šæ–­æœºåˆ¶][https://swift.org/blog/new-diagnostic-arch-overview/]ï¼Œç¼–è¯‘ç³»ç»ŸæŠ¥å‡ºçš„é”™è¯¯ä¿¡æ¯å˜å¾—æ›´åŠ æœ‰ç”¨ã€‚è¿™ä¹Ÿæ˜¯ Xcode ç¬¬ä¸€æ¬¡æä¾›å…¨æ–°çš„ [`sourcekit-lsp` æœåŠ¡å™¨](/language-server-protocol/) ï¼Œå®ƒå¯ä»¥æˆæƒåƒ [VSCode](/vscode/) è¿™ç±»ç¼–è¾‘å™¨æ¥è®©å…¶æ›´å¥½åœ°å…¼å®¹ Swiftã€‚

Yet,
despite all of these improvements
(which are truly an incredible achievement by Apple's Developer Tools team),
much of the early feedback has focused on
the most visible additions to Swift 5.2.
And the response from the peanut galleries of
Twitter, Hacker News, and Reddit has been â€”
to put it charitably â€” _"mixed"_.

ä½†æ˜¯ï¼Œå°½ç®¡ Xcode æœ‰è¿™ä¹ˆå¤šæ–¹é¢çš„æå‡ï¼ˆè¿™ç¡®å®æ˜¯å±äºè‹¹æœå¼€å‘å·¥å…·å›¢é˜Ÿä¸€é¡¹ä»¤äººéš¾ä»¥ç½®ä¿¡çš„æˆå°±ï¼‰ï¼Œä½†ä»æ—©æœŸæœ‰è¾ƒå¤šçš„åé¦ˆæ¥çœ‹ï¼Œæ›´å¤šçš„æ˜¯åœ¨å…³æ³¨ Swfit 5.2 ä¸Šæœ€äº®çœ¼çš„æ–°å¢ç‰¹æ€§ã€‚å¹¶ä¸”æ¥è‡ª Twitterã€Hacker News å’Œ Reddit å„ä¸ªå¹³å°çš„æ„è§éƒ½è¢« *â€œç»¼åˆâ€* èµ·æ¥è€ƒè™‘äº†ã€‚

* * *

If like most of us,
you aren't tuned into the comings-and-goings of [Swift Evolution][swift evolution],
Xcode 11.4 was your first exposure to two new additions to the language:
[key path expressions as functions][se-0249] 
and
[callable values of user-defined nominal types][se-0253].

The first of these allows key paths to replace
one-off closures used by functions like `map`:

```swift
// Swift >= 5.2
"ğŸ§ğŸ­ğŸ¦".unicodeScalars.map(\.properties.name)
// ["CUPCAKE", "LOLLIPOP", "SOFT ICE CREAM"]

// Swift <5.2 equivalent
"ğŸ§ğŸ­ğŸ¦".unicodeScalars.map { $0.properties.name }
```

å¦‚æœä½ è·Ÿæˆ‘ä»¬å¤§å¤šæ•°äººä¸€æ ·ï¼Œæ²¡èƒ½é€‚åº”å¿«é€Ÿçš„ [Swift è¿­ä»£][https://apple.github.io/swift-evolution/]ï¼ŒXcode 11.4 æ˜¯ä½ ç¬¬ä¸€æ¬¡æ¥è§¦åˆ° Swift çš„ä¸¤ä¸ªæ–°ç‰¹æ€§ï¼š[å¯ä½œä¸ºå‡½æ•°çš„å…³é”®è·¯å¾„è¡¨è¾¾å¼][https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md] å’Œ [è‡ªå®šä¹‰ç±»å‹çš„å¯è°ƒç”¨å€¼][https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md]ã€‚

å…¶ä¸­ç¬¬ä¸€ç§ç‰¹æ€§çš„ä½œç”¨æ˜¯ï¼Œå¯ä»¥è®©å…³é”®è·¯å¾„ç”¨å‡½æ•°æ›¿æ¢ä¸€æ¬¡æ€§é—­åŒ…ï¼Œä¾‹å¦‚ `map` å‡½æ•°ï¼š

```swift
// Swift >= 5.2
"ğŸ§ğŸ­ğŸ¦".unicodeScalars.map(\.properties.name)
// ["CUPCAKE", "LOLLIPOP", "SOFT ICE CREAM"]

// Swift ç‰ˆæœ¬ <5.2 çš„ç­‰æ•ˆåšæ³•
"ğŸ§ğŸ­ğŸ¦".unicodeScalars.map { $0.properties.name }


The second allows instances of types with a method named `callAsFunction`
to be called as if they were a function:

```swift
struct Sweetener {
    let additives: Set<Character>

    init<S>(_ sequence: S) where S: Sequence, S.Element == Character {
        self.additives = Set(sequence)
    }

    func callAsFunction(_ message: String) -> String {
        message.split(separator: " ")
               .flatMap { [$0, "\(additives.randomElement()!)"] }
               .joined(separator: " ") + "ğŸ˜‹"
    }
}

let dessertify = Sweetener("ğŸ§ğŸ­ğŸ¦")
dessertify("Hello, world!")
// "Hello, ğŸ­ world! ğŸ¦ğŸ˜‹"
```

ç¬¬äºŒç§ç‰¹æ€§å¯ä»¥è®©å¸¦æœ‰ `callAsFunction` å‡½æ•°çš„ç±»å‹å®ä¾‹ï¼Œä½œä¸ºä¸€ä¸ªå‡½æ•°è¢«è°ƒç”¨ï¼š

```swift
struct Sweetener {
    let additives: Set<Character>

    init<S>(_ sequence: S) where S: Sequence, S.Element == Character {
        self.additives = Set(sequence)
    }

    func callAsFunction(_ message: String) -> String {
        message.split(separator: " ")
               .flatMap { [$0, "\(additives.randomElement()!)"] }
               .joined(separator: " ") + "ğŸ˜‹"
    }
}

let dessertify = Sweetener("ğŸ§ğŸ­ğŸ¦")
dessertify("Hello, world!")
// "Hello, ğŸ­ world! ğŸ¦ğŸ˜‹"
```

* * *

Granted,
both of those examples are terrible.
And that's kinda the problem.

* * *

* * *

å½“ç„¶ï¼Œè¿™ä¸¤ä¸ªä¾‹å­ä¸­çš„ç‰¹æ€§å¹¶æ²¡å¤šå¥½ï¼Œä½†ä»–ä»¬ä¹Ÿæ­£æ˜¯é—®é¢˜æ‰€åœ¨ã€‚

* * *

Too often,
coverage of _"What's New In Swift"_
amounts to little more than a regurgitationï¼ˆå›æµï¼‰ of Swift Evolution proposalsï¼ˆå»ºè®®ï¼‰,
interspersed with poorly motivated (and often emoji-laden) examples.
Such treatments provide a poor characterization of Swift language features,
and â€” in the case of Swift 5.2 â€”
serves to feed into the popular critiqueï¼ˆä¸´ç•Œï¼‰ that these are frivolousï¼ˆæ— èŠçš„ï¼‰ additions ---
mere <dfn>[syntactic sugar][syntactic sugar]</dfn>.

å¾ˆå¤šæ—¶å€™ï¼Œå¾ˆå¤šå…³äº _"Swift æ–°ç‰¹æ€§"_ çš„æŠ¥å¯¼å¹¶ä¸æ˜¯ä»‹ç»æ–°çš„ç‰¹æ€§ï¼Œè€Œæ˜¯åœ¨å¯¹ Swift è¿­ä»£å»ºè®®çš„åé¦ˆï¼Œå¹¶ä¸”ä¼šå¸¦ç€ä¸€äº›è®©äººæä¸å…´è¶£ï¼ˆç»å¸¸å¡«æ»¡ emoji è¡¨æƒ…ï¼‰çš„ç¤ºä¾‹ã€‚è¿™ç±»åšæ³•å¯¼è‡´ Swift è¯­è¨€ç‰¹æ€§çš„é£è¯„å˜å·®ã€‚åƒ Swift 5.2 ç‰ˆæœ¬ï¼Œèˆ†è®ºå°±ä¼šå› æ­¤å‘é…µæˆè¯´è¿™äº›æ–°ç‰¹æ€§ä¸è¿‡æ˜¯æ²¡ç”¨çš„é™„åŠ åŠŸèƒ½ â€”â€” å°±æ˜¯è¯­æ³•ç³– [https://en.wikipedia.org/wiki/Syntactic_sugar]ã€‚


To the extent that we've been guilty of that...
our bad <span lang="und-Zsye">ğŸ™‡â€â™‚ï¸</span>.

æŸç§ç¨‹åº¦ä¸Šè¯´ï¼Œæˆ‘ä»¬éš¾è¾å…¶å’... æˆ‘ä»¬é”™äº† ğŸ™‡â€â™‚ã€‚

This week,
we hope to reach the ooey gooey center of the issue
by providing some historical and theoretical context
for understanding these new features.

åœ¨è¿™ä¸€å‘¨ï¼Œæˆ‘ä»¬å¸Œæœ›èƒ½æ‰¾åˆ°é—®é¢˜çš„å…³é”®æ‰€åœ¨ï¼Œä»¥ä¸€äº›å†å²å’Œç†è®ºèƒŒæ™¯æ¥è§£è¯»è¿™äº›æ–°ç‰¹æ€§ã€‚

## Syntactic Sugar in Swift

If you're salty about "key path as function" being too sugary,
recall that the <span lang="la">status quo</span>
isn't without a sweet tooth.
Consider our saccharine example from before:

```swift
"ğŸ§ğŸ­ğŸ¦".unicodeScalars.map { $0.properties.name }
```

## Swift è¯­æ³•ç³–

ä½ å¯èƒ½ä¸æƒ³è§åˆ° â€œå…³é”®è·¯å¾„å¼å‡½æ•°â€ è¿‡äºå¾€è¯­æ³•ç³–çš„æ–¹å‘å‘å±•ï¼Œä½†ç°åœ¨å·²ç»æœ‰ä¸å°‘è¯­æ³•ç³–çš„åº”ç”¨åœºæ™¯äº†ã€‚å›æƒ³ä¸‹ä¹‹å‰æˆ‘ä»¬ç”¨åˆ°è¯­æ³•ç³–çš„é‚£ä¸ªä¾‹å­ï¼š

```swift
"ğŸ§ğŸ­ğŸ¦".unicodeScalars.map { $0.properties.name }
```

That expression relies on at least four different syntactic concessions:

1. **Trailing closure syntax**,
   which allows a final closure argument label of a function to be omitted
2. **Anonymous closure arguments**,
   which allow arguments in closures to be used positionally (`$0`, `$1`, ...)
   without binding to a named variable.
3. **Inferred parameter and return value types**
4. **Implicit return from single-expression closures** 

If you wanted to cut sugar out of your diet completely,
you'd best get [Mavis Beacon][mavis beacon teaches typing] on the line,
because you'll be doing a lot more [typing](/rawrepresentable/).

```swift
"ğŸ§ğŸ­ğŸ¦".unicodeScalars.map(transform: { (unicodeScalar: Unicode.Scalar) -> String in
    return unicodeScalar.properties.name
})
```

<aside class="parenthetical">

Also, who knew that the argument label in `map` was "transform"?

</aside>

è¿™å¥è¡¨è¾¾å¼ç”¨åˆ°äº†å››ç§ä¸åŒçš„è¯­æ³•æŠ€å·§ï¼š

1. **å°¾éšé—­åŒ…** å…è®¸æœ€åä¸€ä¸ªå‚æ•°æ ‡è®°è¢«çœç•¥ã€‚
2. **åŒ¿åé—­åŒ…å‚æ•°** æ˜¯ä¸€ç§åœ¨é—­åŒ…ä¸­çš„å‚æ•°ï¼ˆ$0ï¼Œ$1ï¼Œâ€¦â€¦ï¼‰æ ¹æ®ä½ç½®æ¥ä½¿ç”¨ï¼Œè€Œä¸”ä¸ç”¨ç»™å‚æ•°ç»‘å®šå‘½å¥½åçš„å˜é‡ã€‚
3. æ¨æ–­å‚æ•°å’Œè¿”å›å€¼ç±»å‹ã€‚
4. å•è¡¨è¾¾å¼é—­åŒ…çš„éšå¼è¿”å›ã€‚

è¦æ˜¯ä½ æƒ³åœ¨å·¥ä½œä¸­æˆ’æ‰â€œç³–â€ï¼Œé‚£ä½ æœ€å¥½è®© [Mavis Beacon][https://en.wikipedia.org/wiki/Mavis_Beacon_Teaches_Typing] æ¥åœ¨çº¿å¸®ä½ æ‰“å­—ï¼Œå› ä¸ºä½ å°†ä¼šéœ€è¦æ‰“å¾ˆå¤šå­—ã€‚

```swift
"ğŸ§ğŸ­ğŸ¦".unicodeScalars.map(transform: { (unicodeScalar: Unicode.Scalar) -> String in
    return unicodeScalar.properties.name
})
```

> å¯¹äº†ï¼Œæœ‰è°çŸ¥é“ `map` é‡Œçš„å‚æ•°æ ‡è®°æ˜¯ â€œtransformâ€ï¼Ÿ

In fact,
as we'll see in the examples to come,
Swift is a marshmallow world in the winter,
_syntactically speaking_.
From initializers and method calls to optionals and method chaining,
nearly everything about Swift could be described as a cotton candy melody â€”
it really just depends on where you draw the line between
"language feature" and "syntactic sugar".

å…¶å®ï¼Œæ­£å¦‚æˆ‘ä»¬æ¥ä¸‹æ¥çš„ä¾‹å­ï¼ŒSwift *ä»å¥æ³•ä¸Šè®²* å°±æ˜¯å†¬å¤©é‡Œä¸€ä¸ªå……æ»¡æ£‰èŠ±ç³–çš„ä¸–ç•Œã€‚ä»åˆå§‹åŒ–æ„é€ å™¨å’Œæ–¹æ³•è°ƒç”¨å²›å¯é€‰å€¼å’Œé“¾å¼æ–¹æ³•è°ƒç”¨ï¼Œå‡ ä¹æ‰€æœ‰å…³äº Swift çš„äº‹æƒ…éƒ½èƒ½çœ‹åˆ°è¯­æ³•ç³–çš„å½±å­â€”â€”å°±çœ‹ä½ æ˜¯å¦‚ä½•åˆ’åˆ†â€œè¯­è¨€ç‰¹æ€§â€å’Œâ€œè¯­æ³•ç³–â€ã€‚

* * *

To understand why,
you have to understand how we got here in the first place,
which requires a bit of history, math, and computer science.
Get ready to eat your vegetables ğŸ¥¦.

è¦ç†è§£å…¶ä¸­åŸå› ï¼Œä½ é¦–å…ˆè¦å¼„æ˜ç™½äº‹æƒ…çš„ç”±æ¥ï¼Œè¿™é‡Œè¦ç”¨åˆ°ä¸€ç‚¹å†å²ã€æ•°å­¦å’Œè®¡ç®—æœºç§‘å­¦çš„çŸ¥è¯†ã€‚åšå¥½å‡†å¤‡æ¥äº«ç”¨å§ã€‚

## The Î»-Calculus and Speculative Computer Science Fiction

## Î»-æ¼”ç®—å’Œè®¡ç®—æœºç§‘å¹»æ¨ç†å°è¯´

All programming languages can be seen as various attempts to represent
[the <abbr lang="la" title="lambda">Î»</abbr>-calculus][lambda calculus].
Everything you need to write code â€”
variables, binding, application â€”
it's all in there,
buried under a mass of Greek letters and mathematical notation.

æ‰€æœ‰çš„ç¼–ç¨‹è¯­è¨€éƒ½å¯ä»¥çœ‹ä½œæ˜¯å¯¹ [Î»æ¼”ç®—][https://en.wikipedia.org/wiki/Lambda_calculus] çš„å„ç§æ¼”ç»å°è¯•ã€‚æ‰€æœ‰ä½ è¦ç”¨ä»£ç ç¼–å†™çš„åœ°æ–¹ â€”â€” å˜é‡ã€ç»‘å®šã€åº”ç”¨ - åœ¨é‡Œé¢éƒ½æœ‰ä½“ç°ï¼Œè¢«å¤§é‡å¸Œè…Šå­—æ¯å’Œæ•°å­¦ç¬¦å·æ©åŸ‹ç€ã€‚

Setting aside syntactic differences,
each programming language can be understood by
its combination of affordances for
making programs easier to write and easier to read.
Language features like
objects,
classes,
modules,
optionals,
literals,
and generics
are all just abstractions built on top of the Î»-calculus.

å¦‚æœæŠ›å¼€è¯­æ³•çš„å·®å¼‚ï¼Œæ¯é—¨ç¼–ç¨‹è¯­è¨€éƒ½å¯ä»¥é€šè¿‡åŠŸèƒ½ç‰¹æ€§çš„ç»„åˆæ¥ç†è§£ï¼Œä»¥ä½¿ç¨‹åºæ›´å®¹æ˜“ç¼–å†™å’Œé˜…è¯»ã€‚åƒå¯¹è±¡ã€ç±»ã€æ¨¡å—ã€å¯é€‰å€¼ã€å­—é¢é‡å’Œæ³›å‹ç­‰è¯­è¨€ç‰¹æ€§éƒ½æ˜¯å»ºç«‹åœ¨Î»æ¼”ç®—ä¸Šå¯¹å…¶ç‰¹æ€§çš„æŠ½è±¡.

Any other deviation from pure mathematical formalism
can be ascribed to real-world constraints,
such as
[a typewriter from the 1870s][qwerty],
[a punch card from the 1920s][punch cards],
[a computer architecture from the 1940s][von neumann],
or [a character encoding from the 1960s][ascii].

ä»»ä½•ç¼–ç¨‹å’Œçº¯æ•°å­¦å½¢å¼ä¸»ä¹‰å­˜åœ¨çš„åå·®ï¼Œéƒ½å¯ä»¥å½’å› äºç°å®ä¸–ç•Œçš„çº¦æŸï¼Œä¾‹å¦‚ [19 ä¸–çºª 70 å¹´ä»£çš„æ‰“å­—æœº][https://en.wikipedia.org/wiki/QWERTY]ã€[20 ä¸–çºª 20 å¹´ä»£çš„ç©¿å­”å¡ç‰‡][https://en.wikipedia.org/wiki/Punched_card#IBM_80-column_punched_card_format_and_character_codes]ã€[40 å¹´ä»£çš„è®¡ç®—æœºä½“ç³»ç»“æ„][https://en.wikipedia.org/wiki/Von_Neumann_architecture] æˆ– [60 å¹´ä»£çš„å­—ç¬¦ç¼–ç ][https://en.wikipedia.org/wiki/ASCII]ã€‚

Among the earliest programming languages were Lisp, ALGOL*, and COBOL,
from which nearly every other language derives.

æœ€æ—©çš„ç¼–ç¨‹è¯­è¨€åŒ…æ‹¬ Lispã€ALGOL*å’Œ COBOLï¼Œå…¶ä»–ç¼–ç¨‹è¯­è¨€å‡ ä¹éƒ½æ˜¯ä»è¿™äº›è¯­è¨€æ´¾ç”Ÿå‡ºæ¥çš„ã€‚

<aside clasS="parenthetical">

We're using FORTRAN as a stand-in here,
for lack of an easily-accessible ALGOL environment.

</aside>

> ç”±äºæ²¡æœ‰æ–¹ä¾¿çš„ ALGOL è®¿é—®ç¯å¢ƒï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œç”¨ FORTRAN ä»£æ›¿ã€‚


```lisp
(defun square (x)
    (* x x))

(print (square 4)) 
;; 16
```

```fortran
pure function square(x)
  integer, intent(in) :: x
  integer :: square
  square = x * x
end function

program main
  integer :: square
  print *, square(4)
end program main
! 16
```

```cobol
IDENTIFICATION DIVISION.
       PROGRAM-ID. example.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01  x   PIC 9(3) VALUE 4.
       01  y   PIC 9(9).
       PROCEDURE DIVISION.
           CALL "square" USING
               BY CONTENT x
               BY REFERENCE y.
           DISPLAY y.
           STOP RUN.
       END PROGRAM example.

IDENTIFICATION DIVISION.
       PROGRAM-ID. square.
       DATA DIVISION.
       LINKAGE SECTION.
       01  x   PIC 9(3).
       01  y   PIC 9(3).
       PROCEDURE DIVISION USING x, y.
           MULTIPLY x BY x GIVING y.
           EXIT PROGRAM.
       END PROGRAM square.
* 016000000
```

Here you get a glimpse into three very different timelines;
ours is the reality in which ALGOL's syntax (option #2)
"won out" over the alternatives.
From ALGOL 60,
you can draw a straight line from
[CPL][cpl] in 1963,
to [BCPL][bcpl] in 1967
and [C] in 1972,
followed by [Objective-C in 1984](/direct/#object-oriented-programming)
and Swift in 2014.
That's the lineage that informs what types are callable and how we call them.

* * *

è¿™é‡Œï¼Œä½ çœ‹åˆ°äº† 3 ç§ä¸åŒæ—¶é—´çº¿çš„ç‰ˆæœ¬ï¼›æˆ‘ä»¬å½“ä¸‹çš„è¿™ä¸€ç§æ˜¯ ALGOL çš„è¯­æ³•ï¼ˆç¬¬äºŒé¡¹ï¼‰ï¼Œå®ƒâ€œèµ¢è¿‡â€äº†å¦å¤–ä¸¤ä¸ªé€‰é¡¹ã€‚ä½ å¯ä»¥è‡ª ALGOL 60 å¼€å§‹è¿½æº¯èµ·ï¼Œä» 1963 å¹´çš„ [CPL][https://en.wikipedia.org/wiki/CPL_(programming_language)] åˆ° 1967 å¹´çš„ [BCPL][https://en.wikipedia.org/wiki/BCPL] å’Œ 1972 å¹´çš„ [C][https://en.wikipedia.org/wiki/C_(programming_language)]ï¼Œå†ä¹‹åçš„ [Objective-C in 1984](/direct/#object-oriented-programming) å’Œ 2014 çš„ Swiftã€‚è¿™å°±æ˜¯å¯è°ƒç”¨ç±»å‹åŠå…¶è°ƒç”¨æ–¹æ³•çš„æ²¿è¢­å†å²ã€‚

* * *

_Now, back to Swift..._

_ç°åœ¨ï¼Œå›åˆ° Swiftâ€¦â€¦_

## Function Types in Swift

Functions are first-class objects in Swift,
meaning that they can be assigned to variables,
stored in properties,
and passed as arguments or returned as values from other functions.

What distinguishes function types from other values
is that they're <dfn>callable</dfn>,
meaning that you can invoke them to produce new values.

## Swift ä¸­çš„å‡½æ•°ç±»å‹

å‡½æ•°æ˜¯ Swift ä¸­çš„ç¬¬ä¸€ç±»å¯¹è±¡ï¼Œè¿™æ„å‘³ç€å®ƒä»¬å¯ä»¥èµ‹å€¼ç»™å˜é‡ã€å­˜å‚¨å±æ€§ã€å½“å‚æ•°ä¼ é€’æˆ–è€…ä½œä¸ºå…¶å®ƒå‡½æ•°çš„è¿”å›å€¼ã€‚

å‡½æ•°ç±»å‹å’Œå…¶å®ƒç±»å‹çš„åŒºåˆ«æ˜¯åœ¨äºå®ƒä»¬å¯ä»¥è¢«è°ƒç”¨ï¼Œä¹Ÿå°±æ˜¯è¯´ä½ å¯ä»¥è°ƒç”¨ä»–å®ƒæ¥ç”Ÿæˆæ–°çš„å€¼ã€‚

### Closures

Swift's fundamental function type is the <dfn>closure</dfn>,
a self-contained unit of functionality.

```swift
let square: (Int) -> Int = { x in x * x }
```

### é—­åŒ…

Swift ä¸­çš„åŸºæœ¬å‡½æ•°ç±»å‹æ˜¯ *é—­åŒ…*ï¼Œå®ƒæ˜¯ä¸€ä¸ªåŠŸèƒ½ç‹¬ç«‹çš„å•å…ƒã€‚

```swift
let square: (Int) -> Int = { x in x * x }
```

As a function type,
you can call a closure by passing the requisite number of arguments
between opening and closing parentheses `()` â€”
<em lang="fr">a la</em> ALGOL.

```swift
square(4) // 16
```

ä½œä¸ºå‡½æ•°ç±»å‹ï¼Œä½ å¯ä»¥é€šè¿‡ä¼ é€’å·¦ã€å³æ‹¬å·ä¸­æŒ‡å®šæ•°é‡çš„å‚æ•°æ¥è°ƒç”¨é—­åŒ…â€”â€”ä¾ç…§ ALGOLã€‚

```swift
square(4) // 16
```

{% info %}

The number of arguments taken by a function type
is known as its <dfn>arity</dfn>.

{% endinfo %}

> ä¸€ä¸ªå‡½æ•°æ‰€èƒ½æ¥æ”¶çš„å‚æ•°æ•°é‡å°±æ˜¯å®ƒçš„ *å‚æ•°ä¸ªæ•°*ã€‚

Closures are so called because they <dfn>close over</dfn> and capture
references to any variables from the context in which they're defined.
However, capturing semantics aren't always desirable,
which is why Swift provides dedicated syntax to a special kind of closure
known as a <dfn>function</dfn>.

é—­åŒ…ä¹‹æ‰€ä»¥æˆä¸ºé—­åŒ…ï¼Œæ˜¯å› ä¸ºå®ƒä»¬æ˜¯å®Œæ•´é—­åˆçš„ï¼Œå¯ä»¥åœ¨å…¶å®šä¹‰çš„ä¸Šä¸‹æ–‡ä¸­æ•è·åˆ°å˜é‡çš„å¼•ç”¨ã€‚ä½†è¿™ç§æ•è·è¯­ä¹‰å¹¶ä¸æ€»æ˜¯æ»¡è¶³ç¼–ç¨‹éœ€æ±‚æ±‚ï¼Œæ‰€ä»¥ Swift æä¾›äº†ä¸“é—¨è¯­æ³•æ¥è¡¨ç¤ºä¸€ç§å¯ä»¥åšä¸º *å‡½æ•°* çš„ç‰¹æ®Šé—­åŒ…ã€‚ 

### Functions

Functions defined at a top-level / global scope
are named closures that don't capture any values.
In Swift,
you declare them with the `func` keyword:

```swift
func square(_ x: Int) -> Int { x * x }
square(4) // 16
```

### å‡½æ•°

åœ¨é¡¶å±‚/å…¨å±€èŒƒå›´å®šä¹‰çš„å‡½æ•°æ˜¯å°±ç§ä¸ä¼šæ•è·ä»»ä½•å€¼çš„é—­åŒ…ã€‚åœ¨ Swift ä¸­ï¼Œä½ å¯ä»¥ç”¨å…³é”®å­— `func` æ¥è¿›è¡Œç”³æ˜ã€‚

```swift
func square(_ x: Int) -> Int { x * x }
square(4) // 16
```

Compared to closures,
functions have greater flexibility in how arguments are passed.

Function arguments can have named labels
instead of a closure's unlabeled, positional arguments â€”
which goes a long way to clarify the effect of code at its call site:

```swift
func deposit(amount: Decimal,
             from source: Account,
             to destination: Account) throws { <#...#> }
try deposit(amount: 1000.00, from: checking, to: savings)
```

å’Œé—­åŒ…ç›¸æ¯”ï¼Œå‡½æ•°åœ¨å€¼çš„ä¼ é€’ä¸Šæœ‰å¾ˆå¤§çš„çµæ´»æ€§ã€‚

å‡½æ•°å‚æ•°å¯ä»¥æœ‰å‘½åæ ‡ç­¾ï¼Œä¸åƒé—­åŒ…æ˜¯æ— æ³•å®šä¹‰æ ‡ç­¾çš„ä½ç½®å‚æ•° â€”â€” è¿™ç§å‘½åæ ‡ç­¾å¾ˆå¥½çš„é˜æ˜äº†ä»£ç çš„ä½œç”¨ã€‚

```swift
func deposit(amount: Decimal,
             from source: Account,
             to destination: Account) throws { <#...#> }
try deposit(amount: 1000.00, from: checking, to: savings)
```

Functions can be [generic][generics],
allowing them to be used for multiple types of arguments:

```swift
func square<T: Numeric>(_ x: T) -> T { x * x }
func increment<T: Numeric>(_ x: T) -> T { x + 1 }
func compose<T>(_ f: @escaping (T) -> T, _ g: @escaping (T) -> T) -> (T) -> T {
    { x in g(f(x)) }
}

compose(increment, square)(4 as Int) // 25 ((4 + 1)Â²)
compose(increment, square)(4.2 as Double) // 27.04 ((4.2 + 1)Â²)
```

å‡½æ•°å¯ä»¥ä»¥ [æ³›å‹][https://docs.swift.org/swift-book/LanguageGuide/Generics.html] å½¢å¼å­˜åœ¨ï¼Œç”¨äºå……å½“å„ç§ç±»å‹çš„å‚æ•°ã€‚
```swift
func square<T: Numeric>(_ x: T) -> T { x * x }
func increment<T: Numeric>(_ x: T) -> T { x + 1 }
func compose<T>(_ f: @escaping (T) -> T, _ g: @escaping (T) -> T) -> (T) -> T {
    { x in g(f(x)) }
}

compose(increment, square)(4 as Int) // 25 ((4 + 1)Â²)
compose(increment, square)(4.2 as Double) // 27.04 ((4.2 + 1)Â²)
```

Functions can also take variadic arguments,
implicit closures,
and default argument values
(allowing for magic expression literals like `#file` and `#line`):

```swift
func print(items: Any...) { <#...#> }

func assert(_ condition: @autoclosure () -> Bool,
            _ message: @autoclosure () -> String = String(),
            file: StaticString = #file,
            line: UInt = #line) { <#...#> }
```

å‡½æ•°è¿˜èƒ½æ¥æ”¶å¯å˜å‚æ•°ã€éšå¼é—­åŒ…å’Œé»˜è®¤å‚æ•°å€¼ï¼ˆå…è®¸ä½¿ç”¨åƒ `#file` å’Œ `#line` è¿™æ ·çš„ç‰¹æ®Šç¼–è¯‘ç¬¦å·ï¼‰ï¼š

```swift
func print(items: Any...) { <#...#> }

func assert(_ condition: @autoclosure () -> Bool,
            _ message: @autoclosure () -> String = String(),
            file: StaticString = #file,
            line: UInt = #line) { <#...#> }
```

And yet,
despite all of this flexibility for accepting arguments,
most functions you'll encounter operate on an _implicit_ `self` argument.
These functions are called methods.

ç„¶è€Œï¼Œå°½ç®¡å‡½æ•°åœ¨å‚æ•°æ¥æ”¶ä¸Šå¾ˆé«˜çš„çµæ´»æ€§ï¼Œä½†ä½ é‡åˆ°çš„å¤§å¤šæ•°å‡½æ•°éƒ½åŸºäºä¸€ä¸ª *éšå¼* çš„ `self` å‚æ•°æ“ä½œçš„ã€‚è¿™äº›å‡½æ•°å°±è¢«ç§°ä½œæ–¹æ³•ã€‚

### Methods

A <dfn>method</dfn> is a function contained by a type.
Methods automatically provide access to `self`,
allowing them to effectively capture the instance on which they're called
as an implicit argument.

```swift
struct Queue<Element> {
    private var elements: [Element] = []

    mutating func push(_ newElement: Element) {
        self.elements.append(newElement)
    }

    mutating func pop() -> Element? {
        guard !self.elements.isEmpty else { return nil }
        return self.elements.removeFirst()
    }
}
```

### æ–¹æ³•

*æ–¹æ³•* å°±æ˜¯ä¸€ä¸ªè¢«å„ç§ç±»å‹åŒ…å«ç€çš„å‡½æ•°ã€‚æ–¹æ³•è‡ªåŠ¨æä¾›äº†å¯¹ `self` çš„è°ƒç”¨ï¼Œå¯ä»¥è®©å®ƒä»¬æœ‰æ•ˆåœ°æ•è·å®ä¾‹ä½œä¸ºéšå¼å‚æ•°è°ƒç”¨ã€‚

{% info %}

Swift goes one step further
by allowing `self.` to be omitted for member access â€”
making the already implicit `self` all the more implicit.

{% endinfo %}

> Swift æ›´è¿›ä¸€æ­¥å…è®¸å†…éƒ¨æˆå‘˜åœ¨è°ƒç”¨æ—¶çœç•¥ `self.` â€”â€” ä½¿å¾—æœ¬å·²æ˜¯éšå¼çš„ `self` æ›´åŠ éšå¯†ã€‚

* * *

Putting everything together,
these syntactic affordances allow Swift code to be
expressive, clear, and concise:

```swift
var queue = Queue<Int>()
queue.push(1)
queue.push(2)
queue.pop() // 1
```

æ€»çš„æ¥è¯´ï¼Œè¿™äº›è¯­æ³•ç‰¹æ€§è®© Swift ä»£ç å˜å¾—æ›´å…·è¡¨ç°åŠ›ã€æ¸…æ™°å’Œç®€æ´ï¼š

```swift
var queue = Queue<Int>()
queue.push(1)
queue.push(2)
queue.pop() // 1
```

Compared to more verbose languages like Objective-C,
the experience of writing Swift is, well, pretty _sweet_.
It's hard to imagine any Swift developers objecting to what we have here 
as being "sugar-coated".

But like a 16oz can of [Surge][surge],
the sugar content of something is often surprising.
Turns out, 
that example from before is far from innocent:

```swift
var queue = Queue<Int>() // desugars to `Queue<Int>.init()`
queue.push(1) // desugars to `Queue.push(&queue)(1)`
```

å’Œ Objective-C è¿™æ ·è¿‡äºå†—é•¿çš„è¯­è¨€ç›¸æ¯”ï¼Œç¼–å†™ Swift çš„è¿‡ç¨‹å¾ˆ *ç¾å¥½*ã€‚å¾ˆæ‡µæ‡‚æƒ³è±¡æœ‰ Swift å¼€å‘ä¼šåå¯¹æˆ‘ä»¬è¿™é‡Œçš„ "ç³–è¡£ç‚®å¼¹"ã€‚

ä½†å°±åƒä¸€ç½ 16 ç›å¸çš„ [Surge][https://en.wikipedia.org/wiki/Surge_(drink)]ï¼Œé‡Œé¢çš„å«ç³–é‡å¾€å¾€ä»¤äººéœ‡æƒŠã€‚æ‰€ä»¥å®é™…ä¸Šï¼Œä¸Šé¢çš„ä¾‹å­å¹¶ä¸æ˜¯é‚£ä¹ˆç®€å•ï¼š

```swift
var queue = Queue<Int>() // ä¸ç”¨è¯­æ³•ç³–çš„è¯åˆ™æ˜¯ `Queue<Int>.init()`
queue.push(1) // ä¸ç”¨è¯­æ³•ç³–çš„è¯åˆ™æ˜¯ `Queue.push(&queue)(1)`
```

All this time,
our so-called "direct" calls to methods and initializers
were actually shorthand for <del>[function currying][currying]</del>
<ins>[partially-applied functions][partial application]</ins>.

ä¸€ç›´ä»¥æ¥ï¼Œæˆ‘ä»¬å¯¹æ–¹æ³•å’Œåˆå§‹åŒ–æ„é€ å™¨çš„â€œç›´æ¥â€è°ƒç”¨ï¼Œå…¶å®æ˜¯ ï½ï½[æŸ¯é‡ŒåŒ–å‡½æ•°][https://en.wikipedia.org/wiki/Currying]ï½ï½ [åå‡½æ•°åº”ç”¨][https://en.wikipedia.org/wiki/Partial_application] çš„ç®€å†™ã€‚

{% info %}

Partial application and currying are often conflated.
In fact, 
[they're distinct but related concepts](https://ericasadun.com/2017/04/03/musings-on-partial-application/).

Early versions of Swift had a dedicated syntax for currying functions,
but it proved less useful than originally anticipated
and was removed by the [second-ever Swift Evolution proposal][se-0002].

```swift
// Swift <3:
func curried(x: Int)(y: String) -> Float {
    return Float(x) + Float(y)!
}

// Swift >=3
func curried(x: Int) -> (String) -> Float {
    return { (y: String) -> Float in
        return Float(x) + Float(y)!
    }
}
```

{% endinfo %}

> åå‡½æ•°åº”ç”¨å’ŒæŸ¯é‡ŒåŒ–ç»å¸¸è¢«æ··ä¸ºä¸€è°ˆã€‚[å®ƒä»¬å½¢å¼ä¸Šè™½æœ‰æ‰€åŒºåˆ«ï¼Œä½†ç†å¿µä¸Šæœ‰ç±»ä¼¼çš„åœ°æ–¹](https://ericasadun.com/2017/04/03/musings-on-partial-application/)ã€‚æ—©èµ·ç‰ˆæœ¬çš„ Swift æœ‰ä¸“é—¨çš„æŸ¯é‡ŒåŒ–å‡½æ•°ï¼Œä½†æ˜¯å®é™…ä¸Šæ²¡æœ‰åŸå…ˆé¢„æ–™çš„é‚£æ ·æœ‰ç”¨ï¼Œåœ¨[ç¬¬äºŒæ¬¡ç‰ˆæœ¬è¿­ä»£][https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md]çš„æ—¶å€™å°±è¢«ç§»é™¤äº†ã€‚

```swift
// Swift <3:
func curried(x: Int)(y: String) -> Float {
    return Float(x) + Float(y)!
}

// Swift >=3
func curried(x: Int) -> (String) -> Float {
    return { (y: String) -> Float in
        return Float(x) + Float(y)!
    }
}
```

With this in mind,
let's now take another look at callable types in Swift more generally.

## {Type, Instance, Member} â¨¯ {Static, Dynamic}

è€ƒè™‘åˆ°è¿™ä¸€ç‚¹ï¼Œç°åœ¨è®©æˆ‘ä»¬çœ‹ä¸‹åœ¨ Swift ä¸­æ›´åŠ æ™®éçš„å¯è°ƒç”¨ç±»å‹ã€‚

## {Type, Instance, Member} â¨¯ {Static, Dynamic}

Since their introduction in Swift 4.2 and Swift 5, respectively,
many developers have had a hard time keeping
`@dynamicMemberLookup` and `@dynamicCallable`
straight in their minds â€”
made even more difficult by the introduction of `callAsFunction` in Swift 5.2.

è‡ªä»å®ƒä»¬åˆ†åˆ«ä» Swift 4.2 å’Œ Swift 5 å¼•å…¥ä»¥æ¥ï¼Œè®¸å¤šå¼€å‘äººå‘˜å¾ˆéš¾åœ¨é¢å¯¹ `@dynamicMemberLookup` å’Œ `@dynamicCallable` æ—¶ä¿æŒå¤´è„‘æ¸…æ™°â€”â€”åœ¨ Swift 5.2 ä¸­å¼•å…¥ `callAsFunction` åï¼Œå°±å˜å¾—æ›´éš¾äº†ã€‚

If you're also confused,
we think the following table can help clear things up:

|             | Static               | Dynamic                    |
|-------------|----------------------|----------------------------|
| Type        | `init`               | _N/A_                      |
| Instance    | **`callAsFunction`** | **`@dynamicCallable`**     |
| Member      | `func`               | **`@dynamicMemberLookup`** |

å¦‚æœä½ ä¹Ÿè§‰å¾—å›°æƒ‘ï¼Œä¸‹é¢çš„è¡¨æ ¼åº”è¯¥å¯ä»¥å¸®ä½ æ¢³ç†æ¸…æ¥šï¼š

|             | Static               | Dynamic                    |
|-------------|----------------------|----------------------------|
| Type        | `init`               | _N/A_                      |
| Instance    | **`callAsFunction`** | **`@dynamicCallable`**     |
| Member      | `func`               | **`@dynamicMemberLookup`** |


Swift has always had static callable types and type members.
What's changed in new versions of Swift
is that instances are now callable,
and both instances and members can now be called dynamically.

Swift ä¸€ç›´éƒ½æœ‰é™æ€å¯è°ƒç”¨ç±»å‹å’Œç±»å‹æˆå‘˜ã€‚æ–°ç‰ˆæœ¬çš„ Swift ä¸­å®ä¾‹å˜æˆå¯è°ƒç”¨ç±»å‹ï¼Œå®ä¾‹å’Œæˆå‘˜ç°åœ¨å‡å¯ä»¥è¢«è°ƒç”¨äº†ã€‚

{% warning %}

You might have noticed the blank spot in our table.
Indeed, there's no way to dynamically call types.
In fact, there's no way to statically call types
other than to invoke initializers â€”
and that's probably for the best.

{% endwarning %}

> ä½ å¯èƒ½æ³¨æ„åˆ°æˆ‘ä»¬è¡¨æ ¼é‡Œçš„ç©ºå†…å®¹å¤„äº†ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬æ˜¯æ²¡åŠæ³•åŠ¨æ€åœ°å»è°ƒç”¨ç±»å‹ã€‚é™¤äº†åœ¨åˆå§‹åŒ–æ„é€ å™¨å†…éƒ¨è°ƒç”¨ï¼Œæ˜¯æ²¡æœ‰å…¶ä»–æ–¹æ³•é™æ€åœ°è°ƒç”¨ç±»å‹â€”â€”è¿™ä¹Ÿè®¸æ‰æ˜¯æœ€åˆç†çš„è®¾è®¡ã€‚
 
Let's see what that means in practice,
starting with static callables.

### Static Callable

```swift
struct Static {
    init() {}

    func callAsFunction() {}

    static func function() {}
    func function() {}
}
```

è®©æˆ‘ä»¬ä»é™æ€å¯è°ƒç”¨ç±»å‹å¼€å§‹çœ‹ä¸‹ï¼Œè¿™æ ·è®¾è®¡å®é™…ä¸Šæ„å‘³ç€ä»€ä¹ˆã€‚

### é™æ€å¯è°ƒç”¨ç±»å‹

```swift
struct Static {
    init() {}

    func callAsFunction() {}

    static func function() {}
    func function() {}
}
```

This type can be called statically in the following ways:

```swift
let instance = Static() // <#â¶#> desugars to `Static.init()`

Static.function() // <#â·#> (no syntactic sugar!)
instance.function() // <#â¸#> desugars to Static.function(instance)()

instance() // <#â¹#> desugars to `Static.callAsFunction(instance)()`
```

è¿™ä¸ªç±»å‹å¯ä»¥ç”¨ä¸‹é¢çš„æ–¹å¼æ¥é™æ€è°ƒç”¨ï¼š

```swift
let instance = Static() // <#â¶#> ä¸ç”¨è¯­æ³•ç³–çš„è¯åˆ™æ˜¯ `Static.init()`

Static.function() // <#â·#> ï¼ˆæ²¡æœ‰è¯­æ³•ç³–!ï¼‰
instance.function() // <#â¸#> ä¸ç”¨è¯­æ³•ç³–çš„è¯åˆ™æ˜¯ Static.function(instance)()

instance() // <#â¹#> ä¸ç”¨è¯­æ³•ç³–çš„è¯åˆ™æ˜¯ `Static.callAsFunction(instance)()`
```

â¶
: Calling the `Static` type invokes an initializer

â· 
: Calling `function` on the `Static` type
  invokes the corresponding static function member,
  passing `Static` as an implicit `self` argument.

â¸
: Calling `function` on an instance of `Static`
  invokes the corresponding function member,
  passing the instance as an implicit `self` argument.

â¹
: Calling an instance of `Static`
  invokes the `callAsFunction()` function member,
  passing the instance as an implicit `self` argument.

â¶
: é€šè¿‡ `Static` ç±»å‹è°ƒç”¨åˆå§‹åŒ–æ„é€ å™¨ã€‚

â· 
: é€šè¿‡ `Static` ç±»å‹çš„ `function` å‡½æ•°ï¼Œå°†å®ä¾‹ä½œä¸ºä¸€ä¸ªéšå¼çš„ `self` å‚æ•°ï¼Œè¿›è€Œè°ƒç”¨ç›¸åº”çš„é™æ€å‡½æ•°æˆå‘˜ã€‚

â¸
: é€šè¿‡ä¸€ä¸ª `Static` å®ä¾‹çš„ `function` å‡½æ•°ï¼Œå°†å®ä¾‹ä½œä¸ºä¸€ä¸ªéšå¼çš„ `self` å‚æ•°ï¼Œè¿›è€Œè°ƒç”¨ç›¸åº”çš„é™æ€å‡½æ•°æˆå‘˜ã€‚

â¹
: é€šè¿‡ä¸€ä¸ª `Static` å®ä¾‹çš„ `function` å‡½æ•°ï¼Œå°†å®ä¾‹ä½œä¸ºä¸€ä¸ªéšå¼çš„ `self` å‚æ•°ï¼Œè¿›è€Œè°ƒç”¨ `callAsFunction()` è¿™ä¸ªå‡½æ•°æˆå‘˜ã€‚

{% info %}

A few points for completeness' sake:

- You can also statically call subscripts and variable members (properties).
- Operators provide an alternative way to invoke static member functions.
- Enumeration cases are, well... 
  something else entirely.

<!-- Interestingly,
     [a draft proposal](https://forums.swift.org/t/enum-cases-as-protocol-witnesses/32753/19)
     to allow enumeration cases to be treated as protocol witnesses
     is currently making the rounds on the Swift forums. -->

{% endinfo %}

> ä¸ºå®Œæ•´èµ·è§ï¼Œè¿˜æœ‰å‡ ç‚¹éœ€è¦æ³¨æ„ï¼š

- ä½ ä»å¯ä»¥é™æ€åœ°è°ƒç”¨ä¸‹æ ‡å’Œå˜é‡æˆå‘˜ï¼ˆå±æ€§ï¼‰ã€‚
- è¿ç®—ç¬¦å¯ä»¥ä½œä¸ºè°ƒç”¨é™æ€å‡½æ•°æˆå‘˜çš„å¦ä¸€ç§æ–¹æ³•ã€‚
- è€Œä¸”æšä¸¾ç±»å‹çš„æšä¸¾é¡¹ä¹Ÿâ€¦â€¦ï¼Œå¥½å§ï¼Œå®Œå…¨æ˜¯å¦å¤–ä¸€å›äº‹ã€‚


### Dynamic Callable

```swift
@dynamicCallable
@dynamicMemberLookup
struct Dynamic {
    func dynamicallyCall(withArguments args: [Int]) -> Void { () }
    func dynamicallyCall(withKeywordArguments args: KeyValuePairs<String, Int>) -> Void { () }

    static subscript(dynamicMember member: String) -> (Int) -> Void { { _ in } }
    subscript(dynamicMember member: String) -> (Int) -> Void { { _ in } }
}
```

### åŠ¨æ€å¯è°ƒç”¨ç±»å‹

```swift
@dynamicCallable
@dynamicMemberLookup
struct Dynamic {
    func dynamicallyCall(withArguments args: [Int]) -> Void { () }
    func dynamicallyCall(withKeywordArguments args: KeyValuePairs<String, Int>) -> Void { () }

    static subscript(dynamicMember member: String) -> (Int) -> Void { { _ in } }
    subscript(dynamicMember member: String) -> (Int) -> Void { { _ in } }
}
```

This type can be called dynamically in a few different ways:

```swift
let instance = Dynamic() // desugars to `Dynamic.init()`

instance(1) // <#â¶#> desugars to `Dynamic.dynamicallyCall(instance)(withArguments: [1])`
instance(a: 1) // <#â·#> desugars to `Dynamic.dynamicallyCall(instance)(withKeywordArguments: ["a": 1])`

Dynamic.function(1) // <#â¸#> desugars to `Dynamic[dynamicMember: "function"](1)`
instance.function(1) // <#â¹#> desugars to `instance[dynamicMember: "function"](1)`
```

è¿™ä¸ªç±»å‹å¯ä»¥é€šè¿‡å°‘æ•°çš„å‡ ç§æ–¹æ³•æ¥è¿›è¡ŒåŠ¨æ€è°ƒç”¨ï¼š

```swift
let instance = Dynamic() // ä¸ç”¨è¯­æ³•ç³–çš„è¯åˆ™æ˜¯ `Dynamic.init()`

instance(1) // <#â¶#> ä¸ç”¨è¯­æ³•ç³–çš„è¯åˆ™æ˜¯ `Dynamic.dynamicallyCall(instance)(withArguments: [1])`
instance(a: 1) // <#â·#> ä¸ç”¨è¯­æ³•ç³–çš„è¯åˆ™æ˜¯ `Dynamic.dynamicallyCall(instance)(withKeywordArguments: ["a": 1])`

Dynamic.function(1) // <#â¸#> ä¸ç”¨è¯­æ³•ç³–çš„è¯åˆ™æ˜¯ `Dynamic[dynamicMember: "function"](1)`
instance.function(1) // <#â¹#> ä¸ç”¨è¯­æ³•ç³–çš„è¯åˆ™æ˜¯ `instance[dynamicMember: "function"](1)`
```

â¶
: Calling an instance of `Dynamic`
  invokes the `dynamicallyCall(withArguments:)` method,
  passing an array of arguments
  and `Dynamic` as an implicit `self` argument.

â·
: Calling an instance of `Dynamic`
  with at least one labeled argument
  invokes the `dynamicallyCall(withKeywordArguments:)` method,
  passing the arguments in a [`KeyValuePairs` object](/keyvaluepairs/)
  and `Dynamic` as an implicit `self` argument.

â¸
: Calling `function` on the `Dynamic` type
  invokes the static `dynamicMember` subscript,
  passing `"function"` as the key;
  here, we call the returned anonymous closure.

â¹
: Calling `function` on an instance of `Dynamic`
  invokes the `dynamicMember` subscript,
  passing `"function"` as the key;
  here, we call the returned anonymous closure.
  
â¶
: é€šè¿‡ä¸€ä¸ª `Static` å®ä¾‹ï¼Œä¼ å…¥ä¸€ä¸ªæ•°ç»„ä½œä¸ºå‚æ•°çš„åŒæ—¶ï¼Œå°† `Dynamic` ä½œä¸ºä¸€ä¸ªéšå¼çš„ `self` å‚æ•°æ¥è°ƒç”¨ `dynamicallyCall(withArguments:)` æ–¹æ³•ã€‚

â·
: é€šè¿‡å¸¦æœ‰è‡³å°‘ä¸€ä¸ªæ ‡ç­¾å‚æ•°çš„ `Dynamic` å®ä¾‹ï¼Œä¼ å…¥ [`é”®å€¼å¯¹` å¯¹è±¡](/keyvaluepairs/) ä½œä¸ºå‚æ•°çš„åŒæ—¶ï¼Œå°† `Dynamic` ä½œä¸ºä¸€ä¸ªéšå¼çš„ `self` å‚æ•°æ¥è°ƒç”¨ `dynamicallyCall(withKeywordArguments:)` æ–¹æ³•ã€‚

â¸
: é€šè¿‡ `Static` ç±»å‹çš„ `function` å‡½æ•°ï¼ŒæŠŠ `"function"` ä½œä¸ºä¸€ä¸ªé”®ä¼ å…¥ï¼Œæ¥è°ƒç”¨é™æ€çš„ `dynamicMember` ä¸‹æ ‡ï¼›è¿™é‡Œæˆ‘ä»¬æŠŠè¿”å›å€¼ç§°ä½œæ˜¯åŒ¿åé—­åŒ…ã€‚

â¹
: é€šè¿‡ä¸€ä¸ª `Static` å®ä¾‹çš„ `function` å‡½æ•°ï¼ŒæŠŠ `"function"` ä½œä¸ºä¸€ä¸ªé”®ä¼ å…¥ï¼Œæ¥è°ƒç”¨ `dynamicMember` ä¸‹æ ‡ï¼›è¿™é‡Œæˆ‘ä»¬æŠŠè¿”å›å€¼ç§°ä½œæ˜¯åŒ¿åé—­åŒ…ã€‚

#### Dynamism by Declaration Attributes

`@dynamicCallable` and `@dynamicMemberLookup`
are declaration attributes,
which means that they can't be applied to existing declarations
through an extension.

#### å£°æ˜å¼å±æ€§çš„åŠ¨æ€æ€§

`@dynamicCallable` å’Œ `@dynamicMemberLookup` æ˜¯å£°æ˜å¼å±æ€§ï¼Œæ„å‘³ç€å®ƒä»¬ä¸èƒ½é€šè¿‡æ‰©å±•å»åº”ç”¨äºå·²å­˜åœ¨çš„å£°æ˜ã€‚

So you can't, for example,
_spice up_ `Int` with [Ruby-ish][rails core_ext array]
natural language accessors:

```swift
@dynamicMemberLookup // âš ï¸ Error: '@dynamicMemberLookup' attribute cannot be applied to this declaration
extension Int {
    static subscript(dynamicMember member: String) -> Int? {
        let string = member.replacingOccurrences(of: "_", with: "-")

        let formatter = NumberFormatter()
        formatter.numberStyle = .spellOut
        return formatter.number(from: string)?.intValue
    }
}

// âš ï¸ Error: Just to be super clear, this doesn't work
Int.forty_two // 42 (hypothetically, if we could apply `@dynamicMemberLookup` in an extension)
```

å°±åƒæ˜¯ä½ æ— æ³•ç”¨ [Ruby å¼][https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/array/access.r] è‡ªç„¶è¯­è¨€è®¿é—®å™¨æè¿° `Int`ï¼š

```swift
@dynamicMemberLookup // âš ï¸ Error: '@dynamicMemberLookup' å±æ€§ä¸èƒ½åº”ç”¨åˆ°è¿™ä¸ªå£°æ˜
extension Int {
    static subscript(dynamicMember member: String) -> Int? {
        let string = member.replacingOccurrences(of: "_", with: "-")

        let formatter = NumberFormatter()
        formatter.numberStyle = .spellOut
        return formatter.number(from: string)?.intValue
    }
}

// âš ï¸ Error: ä¸Šé¢ä»£ç åªæ˜¯ä¸ºäº†å±•ç¤ºæ¸…æ¥šï¼Œå®é™…ä¸Šæ˜¯æ— æ³•è¿è¡Œçš„
Int.forty_two // 42ï¼ˆå‡è®¾æˆ‘ä»¬å¯ä»¥åœ¨æ‰©å±•ä¸Šç”¨ `@dynamicMemberLookup`ï¼‰
```

Contrast this with `callAsFunction`,
which can be added to any type in an extension.

ç”¨ `callAsFunction` å’Œå®ƒç›¸æ¯”ï¼Œ`callAsFunction` å¯ä»¥æ·»åŠ åˆ°æ‰©å±•ä¸­çš„ä»»ä½•ç±»å‹ã€‚

{% info %}

For more information about these new language features,
check out the original Swift Evolution proposals:

- [SE-0195: Introduce User-defined "Dynamic Member Lookup" Types][https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md]
- [SE-0216: Introduce - user-defined dynamically "callable" types][https://github.com/apple/swift-evolution/blob/master/proposals/0216-dynamic-callable.md]
- [SE-0249: Key Path Expressions as Functions][se-0249]
- [SE-0252: Key - Path Member Lookup][se-0252]
- [SE-0253: Callable values of user-defined nominal types][se-0253]

{% endinfo %}

> æƒ³äº†è§£æ›´å¤šå…³äºè¿™ä¸ªæ–°è¯­è¨€ç‰¹æ€§çš„ä¿¡æ¯ï¼Œè¯·æŸ¥çœ‹ Swift Evolution çš„åŸå§‹ææ¡ˆ

- [SE-0195ï¼šä»‹ç»ç”¨æˆ·å®šä¹‰çš„â€œåŠ¨æ€æˆå‘˜æŸ¥æ‰¾â€ç±»å‹][https://github.com/apple/swift-evolution/blob/master/proposals/
- [SE-0216ï¼šä»‹ç» - ç”¨æˆ·å®šä¹‰çš„åŠ¨æ€â€œå¯è°ƒç”¨â€ç±»å‹][https://github.com/apple/swift-evolution/blob/master/proposals/0216-dynamic-callable.md]
- [SE-0249ï¼šé”®è·¯å¾„è¡¨è¾¾å¼å‡½æ•°][https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md]
- [SE-0252ï¼šé”® - è·¯å¾„æˆå‘˜æŸ¥æ‰¾][https://github.com/apple/swift-evolution/blob/master/proposals/0252-keypath-dynamic-member-lookup.md]
- [SE-0253ï¼šç”¨æˆ·å®šä¹‰çš„åä¹‰ç±»å‹å¯è°ƒç”¨å€¼][https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md]

* * *

There's much more to talk about with
`@dynamicMemberLookup`, `@dynamicCallable`, and `callAsFunction`,
and we look forward to covering them all in more detail
in future articles.

* * *

* * *

å…³äº `@dynamicMemberLookup`ã€`@dynamicCallable` å’Œ `callAsFunction` è¿˜æœ‰å¾ˆå¤šè¦è®¨è®ºçš„åœ°æ–¹ï¼Œæˆ‘ä»¬å¸Œæœ›èƒ½åœ¨ä»¥åçš„æ–‡ç« ä¸­æ›´è¯¦ç»†åœ°ä»‹ç»å®ƒä»¬ã€‚

* * *

_But speaking of <del>Ruby</del><ins>Python</ins>..._

*ä½†è¯´åˆ° ~~Ruby~~ Python å°±â€¦â€¦*

## Swift â¨¯ ___________________

## Swift â¨¯ ___________________

Adding to
[our list of _"What code is like"_](/numericcast/):

> Code is like fan fiction.

æ·»åŠ åˆ° [æˆ‘ä»¬çš„ *â€œä»£ç æ˜¯ä»€ä¹ˆ"* ç›®å½•] (/numericcast/)ï¼š

> ä»£ç å°±åƒæ˜¯åŒäººå°è¯´

Sometimes to ship software,
you need to pair up and "ship" different technologies.

æœ‰æ—¶å€™å‘å¸ƒè½¯ä»¶ï¼Œä½ éœ€è¦æˆå¥—å‘å¸ƒï¼Œå¹¶ä¸”â€œæ¨å‡ºâ€ä¸åŒçš„æŠ€æœ¯ã€‚

<aside class="parenthetical">

In a way,
the story of Swift is one of the great, tragic romances in modern computing;
how else might we describe the way
Objective-C sacrificed itself to make Swift possible?

</aside>

> æŸç§ç¨‹åº¦ä¸Šæ¥è¯´ï¼ŒSwift çš„æ•…äº‹æ˜¯ç°ä»£è®¡ç®—æœºæŠ€æœ¯ä¸­æœ€ä¼Ÿå¤§çš„æ‚²å‰§ä¹‹ä¸€ï¼›å¦åˆ™æˆ‘ä»¬è¦æ¥å¦‚ä½•æè¿° Objective-C ä¸ºæˆå°± Swift è€Œç‰ºç‰²è‡ªå·±çš„æ–¹å¼å‘¢ï¼Ÿ

In building these features,
the "powers that be" have ordained that
[Swift replace Python for Machine Learning][s4tf].
Taking for granted that an incremental approach is best,
the way to make that happen is to allow
Swift to interoperate with Python
as seamlessly as it does with Objective-C.
And since Swift 4.2,
we've been [getting pretty close][python interop].

```swift
import Python

let numpy = Python.import("numpy")
let zeros = numpy.ones([2, 4])
/* [[1, 1, 1, 1]
    [1, 1, 1, 1]] */
```

åœ¨æ„å»ºè¿™äº›ç‰¹æ€§çš„è¿‡ç¨‹ä¸­ï¼Œâ€œå½“æƒè€…â€å·²ç»å†³å®šè®© [Swift å–ä»£ Python è¿›è¡Œæœºå™¨å­¦ä¹ ][https://github.com/tensorflow/swift/blob/master/docs/WhySwiftForTensorFlow.md]ã€‚å½“ç„¶ï¼Œæœ€å¥½è¿˜æ˜¯ä¸€æ­¥æ­¥æ¥ï¼Œå®ç°æ–¹æ³•å°±æ˜¯å…è®¸ Swift å’Œ Python èƒ½æ— ç¼äº¤äº’ï¼Œå°±åƒå®ƒå’Œ Objective-C ä¸€æ ·ã€‚ä» Swift 4.2 å¼€å§‹ï¼Œæˆ‘ä»¬ç¦»è¿™ä¸ªç›®æ ‡å·²ç» [ç›¸å½“è¿‘][https://www.tensorflow.org/swift/tutorials/python_interoperability] säº†ã€‚

```swift
import Python

let numpy = Python.import("numpy")
let zeros = numpy.ones([2, 4])
/* [[1, 1, 1, 1]
    [1, 1, 1, 1]] */
```

## The Externalities of Dynamism

The promise of additive changes is that they don't change anything
if you don't want them to.
You can continue to write Swift code
remaining totally ignorant of the features described in this article
(most of us have so far).
But let's be clear:
there are no cost-free abstractions.

## åŠ¨æ€æ€§çš„å¤–éƒ¨æ•ˆåº”

è¿™ä¸ªé™„åŠ ç‰¹æ€§çš„å‰ææ˜¯ä¿è¯å¦‚æœä½ ä¸æƒ³è¦è¿™äº›ç‰¹æ€§ï¼Œä»–ä»¬ä¸ä¼šå¯¹ä»»ä½•ä¸œè¥¿é€ æˆæ”¹å˜ã€‚ä½ å¯ä»¥ç»§ç»­å†™ Swift ä»£ç ï¼Œç»§ç»­å®Œå…¨å¿½ç•¥æœ¬æ–‡æåˆ°çš„ç‰¹æ€§ï¼ˆåˆ°ç›®å‰ä¸ºæ­¢æˆ‘ä»¬éƒ½æ˜¯å¦‚æ­¤ï¼‰ã€‚ä½†æˆ‘ä»¬åº”è¯¥çŸ¥é“ï¼šæ²¡æœ‰å…è´¹çš„æŠ½è±¡ã€‚

Economics uses the term [<dfn>negative externalities</dfn>][externality]
to describe indirect costs incurred by a decision.
Although you don't pay for these features unless you use them,
we all shoulder the burden of a more complex language
that's more difficult to teach, learn, document, and reason about.

ç»æµå­¦ç”¨ [*è´Ÿå¤–éƒ¨æ€§*][https://en.wikipedia.org/wiki/Externality] æ¥æè¿°å†³ç­–æ‰€äº§ç”Ÿçš„é—´æ¥æˆæœ¬ã€‚å°½ç®¡é™¤éä½ ä½¿ç”¨è¿™äº›åŠŸèƒ½ï¼Œå¦åˆ™ä½ ä¸ä¼šä¸ºæ­¤ä»˜å‡ºä»€ä¹ˆï¼Œæˆ‘ä»¬éƒ½è‚©è´Ÿç€ä¸€é—¨æ›´å¤æ‚çš„è¯­è¨€çš„é‡æ‹…ï¼Œè¿™é—¨è¯­è¨€æ›´éš¾æ•™ã€æ›´éš¾å­¦ã€æ›´éš¾è®°å½•ã€æ›´éš¾æ€è€ƒã€‚

* * *

A lot of us who have been with Swift from the beginning
have grown weary of Swift Evolution.
And for those on the outside looking in,
it's unfathomable that we're wasting time on inconsequential "sugar" like this
instead of features that will _really_ move the needle,
like [`async` / `await`][async await].

æˆ‘ä»¬å¾ˆå¤šä»ä¸€å¼€å§‹å°±æ¥è§¦ Swift çš„äººå·²ç»åŒå€¦äº† Swift çš„è¿­ä»£æ›´æ–°ã€‚å¯¹äºé‚£äº›æŒè§‚æœ›æ€åº¦çš„äººæ¥è¯´ï¼Œæˆ‘ä»¬çš„è¿™ç§åšæ³•æ˜¯å¾ˆéš¾è®©äººç†è§£çš„ã€‚ä»–ä»¬è®¤ä¸ºæˆ‘ä»¬å°±æ˜¯æµªè´¹æ—¶é—´åœ¨è¿™äº›æ— å…³ç´§è¦çš„â€œè¯­æ³•ç³–â€ï¼Œè€Œä¸æ˜¯åƒ [`async` / `await`][https://gist.github.com/lattner/429b9070918248274f25b714dcfc7619] è¿™æ · *çœŸæ­£* æœ‰ç”¨çš„åŠŸèƒ½ã€‚

In isolation,
each of these proposals is thoughtful and useful â€” _genuinely_.
We've already [had occasion][dbscan] to use a few of them.
But it can be really hard to judge things on their own technical merits
when they're steeped in emotional baggage.

å•ç‹¬æ¥çœ‹ï¼Œè¿™äº›å»ºè®®ä¸­æ¯ä¸€ä¸ªéƒ½æ˜¯æ·±æ€ç†Ÿè™‘è€Œä¸”æœ‰ç”¨çš„ â€”â€” *çœŸçš„*ã€‚æˆ‘ä»¬å·²ç» [æœ‰æœºä¼š][https://github.com/NSHipster/DBSCAN] å¯ä»¥ç”¨å…¶ä¸­çš„ä¸€äº›ç‰¹æ€§äº†ã€‚ä½†æ˜¯å½“ä»–ä»¬èƒŒè´Ÿç€æ„Ÿæƒ…åŒ…è¢±æ—¶ï¼Œå¾ˆéš¾æ ¹æ®å®ƒä»¬æœ¬èº«çš„æŠ€æœ¯ä¼˜åŠ¿å¯¹ä»–ä»¬è¿›è¡Œåˆ¤æ–­ã€‚

Everyone has their own sugar tolerance,
and it's often informed by what they're accustomed to.
Being cognizant of the [drawbridge effect][drawbridge effect],
I honestly can't tell if I'm out of touch,
or if it's [the children who are wrong][skinner]...

æ¯ä¸ªäººå¯¹ç³–éƒ½æœ‰è‡ªå·±çš„æ¥æ”¶ç¨‹åº¦ï¼Œè¿™é€šå¸¸æ˜¯æ˜¯ç”±ä»–ä»¬çš„ä¹ æƒ¯çš„ä¸œè¥¿å†³å®šçš„ã€‚ä½†æƒ³åˆ° [åŠæ¡¥æ•ˆåº”][https://en.wikipedia.org/wiki/Drawbridge_mentality]ï¼Œæˆ‘çœŸçš„ä¸çŸ¥é“æ˜¯æˆ‘è„±èŠ‚ï¼Œè¿˜æ˜¯è¯´ [å¹´è½»äººæ‰æ˜¯é”™çš„][https://knowyourmeme.com/memes/am-i-out-of-touch]â€¦â€¦

[se-0002]: https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md "SE-0002: Removing currying func declaration syntax"
[se-0195]: https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md "SE-0195: Introduce User-defined \"Dynamic Member Lookup\" Types"
[se-0216]: https://github.com/apple/swift-evolution/blob/master/proposals/0216-dynamic-callable.md "SE-0216: Introduce user-defined dynamically \"callable\" types"
[se-0249]: https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md "SE-0249: Key Path Expressions as Functions"
[se-0252]: https://github.com/apple/swift-evolution/blob/master/proposals/0252-keypath-dynamic-member-lookup.md "SE-0252: Key Path Member Lookup"
[se-0253]: https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md "SE-0253: Callable values of user-defined nominal types"

[xcode 11.4 release notes]: https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes
[xcode 11.4 testing]: https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes#3530390
[xcode 11.4 simulator]: https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes#3530393

[new diagnostics architecture]: https://swift.org/blog/new-diagnostic-arch-overview/ "Swift.org - New Diagnostic Architecture Overview"
[swift evolution]: https://apple.github.io/swift-evolution/ "Swift Evolution Proposals Dashboard"
[syntactic sugar]: https://en.wikipedia.org/wiki/Syntactic_sugar
[church-turing thesis]: https://en.wikipedia.org/wiki/Churchâ€“Turing_thesis "Churchâ€“Turing Thesis"
[lambda calculus]: https://en.wikipedia.org/wiki/Lambda_calculus
**********
[qwerty]: https://en.wikipedia.org/wiki/QWERTY "QWERTY"
[punch cards]: https://en.wikipedia.org/wiki/Punched_card#IBM_80-column_punched_card_format_and_character_codes
[ascii]: https://en.wikipedia.org/wiki/ASCII
[von neumann]: https://en.wikipedia.org/wiki/Von_Neumann_architecture "Von Neumann Architecture"
[piet]: https://en.wikipedia.org/wiki/Esoteric_programming_language#Piet
[cpl]: https://en.wikipedia.org/wiki/CPL_(programming_language)
[bcpl]: https://en.wikipedia.org/wiki/BCPL 
[c]: https://en.wikipedia.org/wiki/C_(programming_language)
[currying]: https://en.wikipedia.org/wiki/Currying
[partial application]: https://en.wikipedia.org/wiki/Partial_application
[mavis beacon teaches typing]: https://en.wikipedia.org/wiki/Mavis_Beacon_Teaches_Typing "Mavis Beacon Teaches Typing"
[generics]: https://docs.swift.org/swift-book/LanguageGuide/Generics.html "The Swift Programming Language - Generics"
[surge]: https://en.wikipedia.org/wiki/Surge_(drink) "SURGE"
[rails core_ext array]: https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/array/access.r
[s4tf]: https://github.com/tensorflow/swift/blob/master/docs/WhySwiftForTensorFlow.md
[python interop]: https://www.tensorflow.org/swift/tutorials/python_interoperability
[externality]: https://en.wikipedia.org/wiki/Externality
[dynamic swift thread]: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160926/027337.html
[async await]: https://gist.github.com/lattner/429b9070918248274f25b714dcfc7619
[dbscan]: https://github.com/NSHipster/DBSCAN
[drawbridge effect]: https://en.wikipedia.org/wiki/Drawbridge_mentality
[skinner]: https://knowyourmeme.com/memes/am-i-out-of-touch

{% asset 'articles/callable.css' %}
