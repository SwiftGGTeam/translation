title: "Swift 中的静态和动态可调用类型"
date: 2020-02-12
tags: [Swift, NSHipster, Callable]
categories: [Swift]
permalink: nshipster-callable
keywords: Swift 5.3, Callable
custom_title: Swift 中的静态和动态可调用类型
description: 如果像我们大多数人一样，你还没有适应 Swift 快速迭代的来龙去脉，在 Xcode 11.4 中你将有机会初次接触该语言的两个新功能：作为函数的关键路径表达式，以及用户自定义的名义类型可调用值。

---
原文链接=https://nshipster.com/callable/
作者=Mattt
原文日期=2020-02-12
译者=
校对=
定稿=

<!--此处开始正文-->

上一周，Apple 发布了 [Xcode 11.4 的第一个 beta 版本](https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes)，这个版本逐渐被证明是近来最实用的更新之一。`XCTest` 框架在使用体验上也有了 [一次巨大地提升](https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes#3530390)，[模拟器](https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes#3530393) 同样也有实质性的提升。但实际上引发最大的关注的是 Swift 的变化。

<!--more-->

在 Xcode 11.4 中，Swift 编译时间不断减少，许多开发者表示他们项目的编译时间减少了 10 - 20%。得益于 [新的诊断机制](https://swift.org/blog/new-diagnostic-arch-overview/)，编译系统报出的错误信息变得更加有用。这也是 Xcode 第一次提供全新的 [`sourcekit-lsp` 服务器](/language-server-protocol/) ，它可以授权像 [VSCode](https://nshipster.com/vscode/) 这类编辑器来让其更好地兼容 Swift。

但是，尽管 Xcode 有这么多方面的提升（这确实是属于苹果开发工具团队一项令人难以置信的成就），但从早期较多的反馈来看，更多的关注是在 Swfit 5.2 上最亮眼的新特性。来自 Twitter、Hacker News 和 Reddit 各个平台的意见也都会被 *“综合”* 起来采纳。

* * *

如果你跟我们大多数人一样，没能适应快速的 [Swift 迭代](https://apple.github.io/swift-evolution/)，Xcode 11.4 是你第一次接触到 Swift 的两个新特性：[可作为函数的关键路径表达式](https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md) 和 [自定义类型的可调用值](https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md)。

其中第一种特性的作用是，可以让关键路径用其表示的函数替换一次性闭包，例如 `map` 函数：

```swift
// Swift >= 5.2
"🧁🍭🍦".unicodeScalars.map(\.properties.name)
// ["CUPCAKE", "LOLLIPOP", "SOFT ICE CREAM"]

// Swift 版本 <5.2 的等效做法
"🧁🍭🍦".unicodeScalars.map { $0.properties.name }
```

第二种特性可以让带有 `callAsFunction` 函数的类型实例，作为一个函数被调用：

```swift
struct Sweetener {
    let additives: Set<Character>

    init<S>(_ sequence: S) where S: Sequence, S.Element == Character {
        self.additives = Set(sequence)
    }

    func callAsFunction(_ message: String) -> String {
        message.split(separator: " ")
               .flatMap { [$0, "\(additives.randomElement()!)"] }
               .joined(separator: " ") + "😋"
    }
}

let dessertify = Sweetener("🧁🍭🍦")
dessertify("Hello, world!")
// "Hello, 🍭 world! 🍦😋"
```

* * *

当然，这两个特性相关的例子并没多好，这也正是问题所在。

* * *

很多时候，关于 *"Swift 新特性"* 的报导并不是介绍新的特性，而是在对 Swift 迭代建议的回复，并且会带着一些让人提不兴趣（经常会放满 emoji 表情）的示例。这类做法导致 Swift 语言特性的风评变差。像 Swift 5.2 版本，舆论就会因此发酵，说这些新特性不过是没用的附加功能 —— 就是些 [语法糖](https://en.wikipedia.org/wiki/Syntactic_sugar)。

某种程度上说，我们难辞其咎…… 我们错了 🙇‍♂。

在这一周，我们希望能找到问题的关键所在，以一些历史和理论背景来解读这些新特性。

## Swift 语法糖

你可能不想见到 “关键路径式函数” 过于往语法糖的方向发展，但现在已经有不少语法糖的应用场景了。回想下之前我们用到语法糖的那个例子：

```swift
"🧁🍭🍦".unicodeScalars.map { $0.properties.name }
```

这句表达式用到了四种不同的语法技巧：

1. **尾随闭包** 允许最后一个参数标记被省略。
2. **匿名闭包参数** 是一种在闭包中根据位置（$0，$1，……）来使用的参数，而且不用给参数指定命好名的变量。
3. 推断参数和返回值类型。
4. 单表达式闭包的隐式返回。

要是你想在工作中戒掉“糖”，那你最好让 [Mavis Beacon](https://en.wikipedia.org/wiki/Mavis_Beacon_Teaches_Typing) 来在线帮你打字，因为你将会需要打很多字。

```swift
"🧁🍭🍦".unicodeScalars.map(transform: { (unicodeScalar: Unicode.Scalar) -> String in
    return unicodeScalar.properties.name
})
```

> 对了，有谁知道 `map` 里的参数标记是 “transform”？

其实，正如我们接下来的例子，Swift *从句法上讲* 就是冬天里一个充满棉花糖的世界。不管是初始化构造器和方法调用，还是可选值和链式方法调用，几乎所有关于 Swift 的事情都能看到语法糖的影子——就看你是如何划分“语言特性”和“语法糖”。

* * *

要理解其中原因，你首先要弄明白事情的由来，这里要用到一点历史、数学和计算机科学的知识。做好准备来享用吧。

## λ-演算和计算机科幻推理小说

所有的编程语言都可以看作是对 [λ演算](https://en.wikipedia.org/wiki/Lambda_calculus) 的各种演绎尝试。所有你要用代码编写的地方 —— 变量、绑定、应用 - 在里面都有体现，被大量希腊字母和数学符号掩埋着。

如果抛开语法的差异，每门编程语言都可以通过功能特性的组合来理解，以使程序更容易编写和阅读。像对象、类、模块、可选值、字面量和泛型等语言特性，都是建立在λ演算上对其特性的抽象.

任何编程和纯数学形式主义存在的偏差，都可以归因于现实世界的技术水平限制，例如 [19 世纪 70 年代的打字机](https://en.wikipedia.org/wiki/QWERTY)、[20 世纪 20 年代的穿孔卡片](https://en.wikipedia.org/wiki/Punched_card#IBM_80-column_punched_card_format_and_character_codes)、[40 年代的计算机体系结构](https://en.wikipedia.org/wiki/Von_Neumann_architecture) 或 [60 年代的字符编码](https://en.wikipedia.org/wiki/ASCII)。

最早期的编程语言包括有 Lisp、ALGOL* 和 COBOL，而所有其他编程语言几乎都是从这些语言派生出来的。

> 由于没有方便的 ALGOL 访问环境，我们在这里用 FORTRAN 代替。


```lisp
(defun square (x)
    (* x x))

(print (square 4)) 
;; 16
```

```fortran
pure function square(x)
  integer, intent(in) :: x
  integer :: square
  square = x * x
end function

program main
  integer :: square
  print *, square(4)
end program main
! 16
```

```cobol
IDENTIFICATION DIVISION.
       PROGRAM-ID. example.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01  x   PIC 9(3) VALUE 4.
       01  y   PIC 9(9).
       PROCEDURE DIVISION.
           CALL "square" USING
               BY CONTENT x
               BY REFERENCE y.
           DISPLAY y.
           STOP RUN.
       END PROGRAM example.

IDENTIFICATION DIVISION.
       PROGRAM-ID. square.
       DATA DIVISION.
       LINKAGE SECTION.
       01  x   PIC 9(3).
       01  y   PIC 9(3).
       PROCEDURE DIVISION USING x, y.
           MULTIPLY x BY x GIVING y.
           EXIT PROGRAM.
       END PROGRAM square.
* 016000000
```

这里，你看到了 3 种不同时间线的版本；我们用的这一种是 ALGOL 的语法（第二项），它“赢过”了另外两个选项。你可以自 ALGOL 60 开始追溯起，从 1963 年的 [CPL](https://en.wikipedia.org/wiki/CPL_(programming_language)) 到 1967 年的 [BCPL](https://en.wikipedia.org/wiki/BCPL) 和 1972 年的 [C](https://en.wikipedia.org/wiki/C_(programming_language))，再之后的 [Objective-C in 1984](/direct/#object-oriented-programming) 和 2014 的 Swift。这就是可调用类型及其调用方法的沿袭历史。

* * *

_现在，回到 Swift……_

## Swift 中的函数类型

函数是 Swift 中的第一类对象，这意味着它们可以赋值给变量、存储属性、当参数传递或者作为其它函数的返回值。

函数类型和其它类型的区别是在于它们可以被调用的，也就是说你可以调用他它来生成新的值。

### 闭包

Swift 中的基本函数类型是 *闭包*，它是一个功能独立的单元。

```swift
let square: (Int) -> Int = { x in x * x }
```

作为函数类型，你可以通过在左、右括号中指定数量的参数来调用闭包——依照 ALGOL。

```swift
square(4) // 16
```

> 一个函数所能接收的参数数量就是它的 *参数个数*。

闭包之所以称为闭包，是因为它们是完整闭合的，可以在其定义的上下文中捕获到变量的引用。但这种捕获语义并不总是满足编程需求求，所以 Swift 提供了专门语法来表示一种可以做为 *函数* 的特殊闭包。 

### 函数

在顶层/全局范围定义的函数是一种不会捕获任何值的闭包。在 Swift 中，你可以用关键字 `func` 来进行声明。

```swift
func square(_ x: Int) -> Int { x * x }
square(4) // 16
```

和闭包相比，函数在值传递上有很大的灵活性。

函数参数可以有命名标签，不像闭包是无法定义标签的位置参数 —— 这种命名标签很好的阐明了代码的作用。

```swift
func deposit(amount: Decimal,
             from source: Account,
             to destination: Account) throws { <#...#> }
try deposit(amount: 1000.00, from: checking, to: savings)
```

函数可以以 [泛型](https://docs.swift.org/swift-book/LanguageGuide/Generics.html) 形式存在，用于充当各种类型的参数。
```swift
func square<T: Numeric>(_ x: T) -> T { x * x }
func increment<T: Numeric>(_ x: T) -> T { x + 1 }
func compose<T>(_ f: @escaping (T) -> T, _ g: @escaping (T) -> T) -> (T) -> T {
    { x in g(f(x)) }
}

compose(increment, square)(4 as Int) // 25 ((4 + 1)²)
compose(increment, square)(4.2 as Double) // 27.04 ((4.2 + 1)²)
```

函数还能接收可变参数、隐式闭包和默认参数值（允许使用像 `#file` 和 `#line` 这样的特殊编译符号）：

```swift
func print(items: Any...) { <#...#> }

func assert(_ condition: @autoclosure () -> Bool,
            _ message: @autoclosure () -> String = String(),
            file: StaticString = #file,
            line: UInt = #line) { <#...#> }
```

然而，尽管函数在参数接收上很高的灵活性，但你遇到的大多数函数都基于一个 *隐式* 的 `self` 参数操作的。这些函数就被称作方法。

### 方法

*方法* 就是一个被各种类型围绕着的函数。方法自动提供了对 `self` 的调用，可以让它们有效地捕获实例作为隐式参数调用。

```swift
struct Queue<Element> {
    private var elements: [Element] = []

    mutating func push(_ newElement: Element) {
        self.elements.append(newElement)
    }

    mutating func pop() -> Element? {
        guard !self.elements.isEmpty else { return nil }
        return self.elements.removeFirst()
    }
}
```

> Swift 更进一步允许内部成员在调用时省略 `self.` —— 使得本已是隐式的 `self` 更加隐密。

* * *

总的来说，这些语法特性让 Swift 代码变得更具表现力、清晰和简洁：

```swift
var queue = Queue<Int>()
queue.push(1)
queue.push(2)
queue.pop() // 1
```

和 Objective-C 这样过于冗长的语言相比，编写 Swift 的过程很 *美好*。很难想象有 Swift 开发者会反对我们的“糖衣炮弹”。

但就像一罐 16 盎司的 [Surge](https://en.wikipedia.org/wiki/Surge_(drink))，里面的含糖量往往是惊人的。所以实际上，上面的例子并不是那么简单：

```swift
var queue = Queue<Int>() // 不用语法糖的话则是 `Queue<Int>.init()`
queue.push(1) // 不用语法糖的话则是 `Queue.push(&queue)(1)`
```

一直以来，我们对方法和初始化构造器的“直接”调用，其实是 ~~[柯里化函数](https://en.wikipedia.org/wiki/Currying]~~ [偏函数应用](https://en.wikipedia.org/wiki/Partial_application) 的简写。

> 偏函数应用和柯里化经常被混为一谈。[它们形式上虽有所区别，但理念上有类似的地方](https://ericasadun.com/2017/04/03/musings-on-partial-application/)。早起版本的 Swift 有专门的柯里化函数，但是实际上没有原先预料的那样有用，在 [第二次版本迭代](https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md) 的时候就被移除了。

```swift
// Swift <3:
func curried(x: Int)(y: String) -> Float {
    return Float(x) + Float(y)!
}

// Swift >=3
func curried(x: Int) -> (String) -> Float {
    return { (y: String) -> Float in
        return Float(x) + Float(y)!
    }
}
```

清楚这些之后，现在让我们来看下 Swift 中更加常见的可调用类型。

## {类型, 实例, 成员} ⨯ {静态, 动态}

自从 `@dynamicMemberLookup` 和 `@dynamicCallable` 分别从 Swift 4.2 和 Swift 5 引入以来，许多开发人员很难在面对它们时保持头脑清晰——在 Swift 5.2 中引入 `callAsFunction` 后，就变得更难了。

如果你也觉得困惑，下面的表格应该可以帮你梳理清楚：

|             | Static               | Dynamic                    |
|-------------|----------------------|----------------------------|
| Type        | `init`               | _N/A_                      |
| Instance    | **`callAsFunction`** | **`@dynamicCallable`**     |
| Member      | `func`               | **`@dynamicMemberLookup`** |

Swift 一直都有静态的可调用类型和类型成员。新版本的 Swift 中实例变成可调用类型，实例和成员现在均可以被调用了。

> 你可能注意到我们表格里的空内容处了。实际上，我们是没办法动态地去调用类型。除了在初始化构造器内部调用，是没有其他方法静态地调用类型——这也许才是最合理的设计。

让我们从静态可调用类型开始看下，这样设计实际上意味着什么。

### 静态可调用类型

```swift
struct Static {
    init() {}

    func callAsFunction() {}

    static func function() {}
    func function() {}
}
```

这个类型可以用下面的方式来静态调用：

```swift
let instance = Static() // ❶ 不用语法糖的话则是 `Static.init()`

Static.function() // ❷ （没有语法糖!）
instance.function() // ❸ 不用语法糖的话则是 Static.function(instance)()

instance() // ❹ 不用语法糖的话则是 `Static.callAsFunction(instance)()`
```

❶
: 通过 `Static` 类型调用初始化构造器。

❷ 
: 通过 `Static` 类型的 `function` 函数，将实例作为一个隐式的 `self` 参数，进而调用相应的静态函数成员。

❸
: 通过一个 `Static` 实例的 `function` 函数，将实例作为一个隐式的 `self` 参数，进而调用相应的静态函数成员。

❹
: 通过一个 `Static` 实例的 `function` 函数，将实例作为一个隐式的 `self` 参数，进而调用 `callAsFunction()` 这个函数成员。

> 为完整起见，还有几点需要注意：

- 你仍可以静态地调用下标和变量成员（属性）。
- 运算符可以作为调用静态函数成员的另一种方法。
- 而且枚举类型的枚举项也……，好吧，完全是另外一回事。

### 动态可调用类型

```swift
@dynamicCallable
@dynamicMemberLookup
struct Dynamic {
    func dynamicallyCall(withArguments args: [Int]) -> Void { () }
    func dynamicallyCall(withKeywordArguments args: KeyValuePairs<String, Int>) -> Void { () }

    static subscript(dynamicMember member: String) -> (Int) -> Void { { _ in } }
    subscript(dynamicMember member: String) -> (Int) -> Void { { _ in } }
}
```

这个类型可以通过少数的几种方法来进行动态调用：

```swift
let instance = Dynamic() // 不用语法糖的话则是 `Dynamic.init()`

instance(1) // ❶ 不用语法糖的话则是 `Dynamic.dynamicallyCall(instance)(withArguments: [1])`
instance(a: 1) // ❷ 不用语法糖的话则是 `Dynamic.dynamicallyCall(instance)(withKeywordArguments: ["a": 1])`

Dynamic.function(1) // ❸ 不用语法糖的话则是 `Dynamic[dynamicMember: "function"](1)`
instance.function(1) // ❹ 不用语法糖的话则是 `instance[dynamicMember: "function"](1)`
```
  
❶
: 通过一个 `Static` 实例，传入一个数组作为参数的同时，将 `Dynamic` 作为一个隐式的 `self` 参数来调用 `dynamicallyCall(withArguments:)` 方法。

❷
: 通过带有至少一个标签参数的 `Dynamic` 实例，传入 [`键值对` 对象](https://nshipster.com/keyvaluepairs/) 作为参数的同时，将 `Dynamic` 作为一个隐式的 `self` 参数来调用 `dynamicallyCall(withKeywordArguments:)` 方法。

❸
: 通过 `Static` 类型的 `function` 函数，把 `"function"` 作为一个键传入，来调用静态的 `dynamicMember` 下标；这里我们把返回值称作是匿名闭包。

❹
: 通过一个 `Static` 实例的 `function` 函数，把 `"function"` 作为一个键传入，来调用 `dynamicMember` 下标；这里我们把返回值称作是匿名闭包。

#### 声明式属性的动态性

`@dynamicCallable` 和 `@dynamicMemberLookup` 是声明式属性，意味着它们不能通过扩展去应用于已存在的声明。


就像是你无法用 [Ruby 式](https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/array/access.r) 自然语言访问器描述 `Int`：

```swift
@dynamicMemberLookup // ⚠︎ Error: '@dynamicMemberLookup' 属性不能应用到这个声明
extension Int {
    static subscript(dynamicMember member: String) -> Int? {
        let string = member.replacingOccurrences(of: "_", with: "-")

        let formatter = NumberFormatter()
        formatter.numberStyle = .spellOut
        return formatter.number(from: string)?.intValue
    }
}

// ⚠︎ Error: 上面代码只是为了展示清楚，实际上是无法运行的
Int.forty_two // 42（假设我们可以在扩展上用 `@dynamicMemberLookup`）
```

`callAsFunction` 和它相比，`callAsFunction` 可以添加到扩展中的任何类型。

> 想了解更多关于这个新语言特性的信息，请查看 Swift Evolution 的原始提案

- [SE-0195：介绍用户定义的“动态成员查找”类型](https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md)
- [SE-0216：介绍 - 用户定义的动态“可调用”类型](https://github.com/apple/)
- [SE-0249：键路径表达式函数](https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md)
- [SE-0252：键 - 路径成员查找](https://github.com/apple/swift-evolution/blob/master/proposals/0252-keypath-dynamic-member-lookup.md)
- [SE-0253：用户定义的名义类型可调用值](https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md)

* * *

关于 `@dynamicMemberLookup`、`@dynamicCallable` 和 `callAsFunction` 还有很多要讨论的地方，我们希望能在以后的文章中更详细地介绍它们。

* * *

*但说到 ~~Ruby~~ Python 就……*

## Swift ⨯ ___________________

添加到 [我们的 *“代码是什么"* 目录](https://nshipster.com/numericcast/)：

> 代码就像是同人小说

有时候发布软件，你需要成套发布，并且“推出”不同的技术。

> 某种程度上来说，Swift 的故事是现代计算机技术中最伟大的悲剧之一；否则我们要来如何评价 Objective-C 为成就 Swift 而牺牲自己的方式呢？

在构建这些特性的过程中，“当权者”已经决定让 [Swift 取代 Python 进行机器学习](https://github.com/tensorflow/swift/blob/master/docs/WhySwiftForTensorFlow.md)。当然，最好还是一步步来，实现方法就是允许 Swift 和 Python 能无缝交互，就像它和 Objective-C 一样。从 Swift 4.2 开始，我们离这个目标已经 [相当近](https://www.tensorflow.org/swift/tutorials/python_interoperability) 了。

```swift
import Python

let numpy = Python.import("numpy")
let zeros = numpy.ones([2, 4])
/* [[1, 1, 1, 1]
    [1, 1, 1, 1]] */
```

## 动态性的外部效应

这个附加特性的前提是保证，如果你不想要这些特性，他们就不会对任何东西造成改变。你可以继续写 Swift 代码，完全忽略本文提到的特性（到目前为止我们都是如此）。但我们应该知道：没有免费的抽象。

经济学用 [*负外部性*](https://en.wikipedia.org/wiki/Externality) 来描述决策所产生的间接成本。尽管除非你使用这些功能，否则你不会为此付出什么，我们都肩负着一门更复杂的语言的重担，这门语言更难教、更难学、更难记录、更难思考。

* * *

我们很多从一开始就接触 Swift 的人已经厌倦了 Swift 的迭代更新。对于那些持观望态度的人来说，我们的这种做法是很难让人理解的。他们认为我们就是浪费时间在这些无关紧要的“语法糖”上，而不是像 [`async` / `await`](https://gist.github.com/lattner/429b9070918248274f25b714dcfc7619) 这样 *真正* 有用的功能。

单独来看，这些建议中每一个都是深思熟虑而且有用的 —— *真的*。我们已经 [有机会](https://github.com/NSHipster/DBSCAN) 可以用其中的一些特性了。但是当他们背负着感情包袱时，很难根据它们本身的技术优势对他们进行判断。

每个人对糖都有自己的接受程度，这通常是是由他们的习惯决定的。但想到 [吊桥效应](https://en.wikipedia.org/wiki/Drawbridge_mentality)，我真的不知道是我脱节，还是说 [年轻人们才是错的](https://knowyourmeme.com/memes/am-i-out-of-touch)……
