---
title: Objective-C Direct Methods
author: Mattt
category: Objective-C
excerpt: >-
  It's hard to get excited when new features come to Objective-C.
  These days,
  any such improvements are in service of Swift interoperability
  rather than an investment in the language itself.
  So it was surprising to learn about
  a recent patch to Clang.

  现在我们很少为 Objective-C 的新特性而兴奋。因为任何此类改进都是为了增强与 Swift 的互操作性，而不是对语言本身的投资。因此，最近合并到 Clang 的补丁令人十分惊讶。
---

It's hard to get excited when new features come to Objective-C.
These days,
any such improvements are in service of Swift interoperability
rather than an investment in the language itself
_(see [nullability](https://developer.apple.com/swift/blog/?id=25)
and [lightweight generics](https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/using_imported_lightweight_generics_in_swift))_.

现在我们很少为 Objective-C 的新特性而兴奋。因为任何此类改进都是为了增强与 Swift 的互操作性，而不是对语言本身的投资。_(见 [nullability](https://developer.apple.com/swift/blog/?id=25)
和 [轻量级范型（lightweight generics）](https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/using_imported_lightweight_generics_in_swift))_

So it was surprising to learn about
[this recently merged patch to Clang](https://reviews.llvm.org/D69991),
which adds a new direct dispatch mechanism to Objective-C methods.

因此，[最近合并到 Clang 的补丁](https://reviews.llvm.org/D69991) 令人十分惊讶，它为 Objective-C 方法增加了一种新的直接派发（Direct Dispatch）机制。

The genesis of this new language feature is unclear;
the most we have to go on is an Apple-internal [Radar number](/bug-reporting/)
([`2684889`](rdar://2684889)),
which doesn't tell us much beyond its relative age
(sometime in the early '00s, by our estimation).
Fortunately,
[the feature landed](https://github.com/llvm/llvm-project/commit/d4e1ba3fa9dfec2613bdcc7db0b58dea490c56b1)
with enough documentation and test coverage
to get a good idea of how it works.
_(Kudos to implementor Pierre Habouzit,
review manager John McCall,
and the other LLVM contributors)_.

这种新特征的起源尚不清楚，我们最多只能找到苹果内部的一个 [Radar 号](/bug-reporting/)
([`2684889`](rdar://2684889))。不过除了用来估算它的相对年龄(据我们估计，大约在20世纪初)，这个 Radar 号什么用也没有。幸运的是，[这个特性](https://github.com/llvm/llvm-project/commit/d4e1ba3fa9dfec2613bdcc7db0b58dea490c56b1) 提供了足够的文档和测试覆盖，可以很好地了解它是如何工作的。(向它的实现者 Pierre Habouzit、评审经理 John McCall 和其他 LLVM 贡献者致敬)。

This week on NSHipster,
we're taking this occasion to review Objective-C method dispatching
and try to understand the potential impact of this new language feature
on future codebases.

在这周的 NSHipster 上，我们将借此机会回顾 Objective-C 的方法调度机制，并试图理解语言的这个新特性对未来代码库的潜在影响。

<aside class="parenthetical">

Direct methods could show up as early as Xcode 11.x,
but most likely, it'll be announced at WWDC 2020.

直接方法（Direct Method）最早会在 Xcode 11.x 上出现，但很有可能在 WWDC 2020 上宣布。

</aside>

---

To understand the significance of direct methods,
you need to know a few things about the Objective-C runtime.
But let's start our discussion one step before that,
to the origin of <abbr title="object-oriented programming">OOP</abbr> itself:

要理解直接方法的重要性，你需要先了解 Objective-C 运行时的一些东西。但在此之前，让我们先讨论一下 `面向对象编程` (`OOP`) 本身的起源：

## Object-Oriented Programming

## 面向对象编程 (Object-Oriented Programming)

Alan Kay coined the term <dfn>"object-oriented programming</dfn> in the late 1960s.
With the help of Adele Goldberg, Dan Ingalls, and his other colleagues at
Xerox <abbr title="Palo Alto Research Center">PARC</abbr>,
Kay put this idea into practice in the '70s
with the creation of the Smalltalk programming language.

Alan Kay 在 20 世纪 60 年代末创造了“面向对象编程”这个术语。在 Adele Goldberg、Dan Ingalls 和施乐帕洛阿尔托研究中心同事们的帮助下，Kay 在 70 年代将这个想法付诸实践，发明了 Smalltalk 编程语言。

<aside class="parenthetical">

During this time, researches at Xerox PARC also developed the
[Xerox Alto](https://en.wikipedia.org/wiki/Xerox_Alto),
which would become the inspiration for Apple's Macintosh
and all other <abbr title="graphical user interface">GUI</abbr> computers.

在此期间，施乐帕洛阿尔托研究中心的研究人员还开发了 [Xerox Alto](https://en.wikipedia.org/wiki/Xerox_Alto)，这也成为苹果 Macintosh 和所有其他图形用户界面计算机的灵感来源。

</aside>

In the 1980s,
Brad Cox and Tom Love started work the first version of Objective-C,
a language that sought to take the object-oriented paradigm of Smalltalk
and implement it on solid fundamentals of C.
Through a series of fortuitous events in the '90s,
the language would come to be the official language of NeXT,
and later, Apple.

1980 年代 Brad Cox 和 Tom Love 开始开发 Objective-C 的第一个版本，寻求在坚实的 C 语言基础上实现 Smalltalk 的面向对象模式。经过 90 年代一系列的偶然事件，这门语言成为了 NeXT，以及接下来的 Apple 的官方语言。

For those of us who started learning Objective-C in the iPhone era,
the language was often seen as yet another proprietary Apple technology ---
one of a myriad, obscure byproducts of the company's
["Not invented here"](https://en.wikipedia.org/wiki/Not_invented_here)
(<abbr title="not invented here">NIH</abbr>) culture.
However,
Objective-C isn't just "an object-oriented C",
it's one of _the original_ object-oriented languages,
with as strong a claim to <abbr>OOP</abbr> credentials as any other.

对于我们这些在 iPhone 时代开始学习 Objective-C 的人来说，这门语言常常被视为苹果的又一项专利技术 —— 它是该公司 “[非我所创（Not invented here，NIH）](https://zh.wikipedia.org/wiki/非我所創)” 文化下众多晦涩的副产品之一。然而，Objective-C 不仅仅是“一个面向对象的 C 语言”，它更是一门 _为了面向对象而生的_ 语言，和其他任何语言一样，都有很强的面向对象特征。

Now, what does <abbr>OOP</abbr> mean?
That's a good question.
'90s era hype cycles have rendered the term almost meaningless.
However,
for our purposes today,
let's focus on something Alan Kay wrote in 1998:

`OOP` 是什么意思呢？问得好。90年代的反复炒作让这个词变得几乎毫无意义。然而，为了今天的目的，让我们关注一下 Alan Kay 1998 年写的东西:

> I'm sorry that I long ago coined the
> term "objects" for this topic because it gets many people to
> focus on the lesser idea.
> The big idea is "messaging" [...] > <cite><a href="https://wiki.c2.com/?AlanKayOnMessaging">Alan Kay</a></cite>

> 我很抱歉，很久以前为这个主题创造了“对象”这个术语，因为它使许多人把注意力集中在这些次要思想上。其实主要思想是“消息传递”[…]>
> —— [Alan Kay](https://wiki.c2.com/?AlanKayOnMessaging)

## Dynamic Dispatch and the Objective-C Runtime

## 动态派发（Dynamic Dispatch）和 Objective-C 运行时

In Objective-C,
a program consists of a collection of objects
that interact with each other by passing messages that, in turn,
invoke <dfn>methods</dfn>, or functions.
This act of message passing is denoted by square bracket syntax:

在 Objective-C 中，程序由一组对象组成，这些对象通过消息传递来进行交互，而这些消息又反过来调用 _方法_ 或函数。这种消息传递行为用方括号语法表示:

```objc
[someObject aMethod:withAnArgument];
```

When Objective-C code is compiled,
message sends are transformed into calls to a function called
[`objc_msgSend`](https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend)
(literally _"send a message to some object with an argument"_).

Objective-C 代码编译后，消息发送被翻译成为调用一个名为 [`objc_msgSend`](https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend)
 的函数(字面意思上的 _“给某个对象发送带有参数的消息”_).

```objc
objc_msgSend(object, @selector(message), withAnArgument);
```

- The first argument is the receiver (`self` for instance methods)
- The second argument is `_cmd`: the selector, or name of the method
- Any method parameters are passed as additional function arguments

- 第一个参数是接收者（实例方法上是 `self`）
- 第二个参数是 `_cmd`：selector 或者方法名
- 方法的所有参数都作为函数的附加参数传递

`objc_msgSend` is responsible for determining
which underlying implementation to call in response to this message,
a process known as <dfn>method dispatch</dfn>.

`objc_msgSend` 负责确定调用哪个底层实现来响应此消息，这个过程被成为 _方法派发（Method Dispatch）_。

In Objective-C,
each class (`Class`) maintains a dispatch table to resolve messages sent at runtime.
Each entry in the dispatch table is a method (`Method`)
that keys a selector (`SEL`)
to a corresponding implementation (`IMP`),
which is a pointer to a C function.
When an object receives a message,
it consults the dispatch table of its class.
If it can find an implementation for the selector,
the associated function is called.
Otherwise,
the object consults the dispatch table of its superclass.
This continues up the inheritance chain until a match is found
or the root class (`NSObject`) deems the selector to be unrecognized.

在 Objective-C 中，每个类（`class`）都维护着一个 dispatch table（派发表），用于在运行时处理消息。dispatch table 的每一项都是一个方法（`Method`），它关联着一个 selector（`SEL`），和对应的实现（`IMP`），即一个 C 函数的指针。对象收到消息后，查询它所在类的 dispatch table。如果能找到该 selector 的实现，那么对应的函数将被调用。否则，对象将查询父类的 dispatch table。这个过程会沿着继承链一直向上，直到找到匹配项，或者由根类（`NSObject`）决定无法识别该 selector。

<aside class="parenthetical">

And that's to say nothing of how Objective-C lets you do things like
replace method implementations and create new classes
dynamically at runtime.
It's absolutely wild what you can do.

这里面还不包括 Objective-C 如何让你替换方法实现以及在运行时动态创建新类。你所能做的绝对是疯狂的。

</aside>

If you think all of this indirection sounds like a lot of work...
in a way,
you'd be right!

如果你觉得所有这些间接操作似乎做了很多事情……在某种程度上，你是对的!

If you have a hot path in your code,
an expensive method that's called frequently,
you could imagine some benefit to avoiding all of this indirection.
To that end,
some developers have used C functions as a way around dynamic dispatch.

如果你的代码中有一个热路径(被频繁调用的昂贵方法)，你能想象避免这些间接方法所带来的好处。为此，一些开发人员使用 C 函数作为绕过动态派发的一种方法。

## Direct Dispatch with a C Function

## 基于 C 函数的直接派发

As we saw with `objc_msgSend`,
any method invocation can be represented by an equivalent function
by passing implicit `self` as the first argument.

正如我们在 `objc_msgSend` 中看到的，任何的方法调用都可以表示为一个等价的函数，该函数的第一个参数是方法中隐式的 `self`。

For example,
consider the following declaration of an Objective-C class
with a conventional, dynamically-dispatched method.

例如，考虑下面这个使用常规的动态派发方法所声明的 Objective-C 类。

```objc
@interface MyClass: NSObject
- (void)dynamicMethod;
@end
```

If a developer wanted to implement some functionality on `MyClass`
without going through the whole message sending shebang,
they could declare a static C function
that took an instance of `MyClass` as an argument.

如果开发人员希望在 `MyClass` 上实现某些功能，但不想走整个消息发送过程，那么他们可以声明一个静态 C 函数，以 `MyClass` 的一个实例作为参数。

```objc
static void directFunction(MyClass *__unsafe_unretained object);
```

Here's how each of these approaches translates to the call site:

下面是如何使用这些方式进行调用：

```objc
MyClass *object = [[[MyClass] alloc] init];

// Dynamic Dispatch
// 动态派发
[object dynamicMethod];

// Direct Dispatch
// 直接派发
directFunction(object);
```

## Direct Methods

## 直接方法

A <dfn>direct method</dfn> has the look and feel of a conventional method,
but has the behavior of a C function.
When a direct method is called,
it directly calls its underlying implementation
rather than going through `objc_msgSend`.

_直接方法_ 看起来跟传统方法差不多，但它的行为却跟 C 函数一样。调用直接方法时，会直接调用它的底层实现，而不是走 `objc_msgSend`。

With this new LLVM patch,
you now have a way to annotate Objective-C methods
to avoid participation in dynamic dispatch selectively.

通过这个新的 LLVM 补丁，你现在有了一种注释 Objective-C 方法的方式，从而选择性地避免参与动态派发。

### objc_direct, @property(direct), and objc_direct_members

### objc_direct, @property(direct) 和 objc_direct_members

To make an instance or class method direct,
you can mark it with the `objc_direct`
[Clang attribute](/__attribute__/).
Likewise,
the methods for an Objective-C property can be made direct
by declaring it with the `direct` property attribute.

通过将一个实例方法或者类方法标记为 `objc_direct` [Clang 属性](https://nshipster.com/__attribute__/)，你可以将它们变为直接方法。类似的，通过将 Objective-C 的 property 标记为 `direct` ，也可以将 property 的方法变为直接方法。

```objc
@interface MyClass: NSObject
@property(nonatomic) BOOL dynamicProperty;
@property(nonatomic, direct) BOOL directProperty;

- (void)dynamicMethod;
- (void)directMethod __attribute__((objc_direct));
@end
```

{% info %}

By our count,
the addition of `direct` brings the total number of `@property` attributes to 16:

根据我们的统计，添加 `direct` 后 `@property` 的属性总数达到 16 个:

- `getter` and
  `setter`
- `readwrite` and
  `readonly`,
- `atomic` and
  `nonatomic`
- `weak`,
  `strong`,
  `copy`,
  `retain`, and
  `unsafe_unretained`
- `nullable`,
  `nonnullable`, and
  `null_resettable`
- `class`

- `getter` 和 `setter`
- `readwrite` 和 `readonly`
- `atomic` 和 `nonatomic`
- `weak`，`strong`，`copy`，`retain` 和 `unsafe_unretained`
- `nullable`，`nonnullable` 和 `null_resettable`
- `class`

{% endinfo %}

When an `@interface` for
a category or class extension is annotated with the `objc_direct_members` attribute,
all method and property declarations contained within it
are considered to be direct,
unless previously declared by that class.

使用 `objc_direct_members` 注释 category 或者 class extension 的 `@interface` 后，它里面声明的所有方法和 property 都将被视为“直接”的，除非它们已经在 class 中声明过了。

{% warning %}

You can't annotate the primary class interface
with the `objc_direct_members` attribute.

你不能使用 `objc_direct_members` 属性注释 class 的主 interface。

{% endwarning %}

```objc
__attribute__((objc_direct_members))
@interface MyClass ()
@property (nonatomic) BOOL directExtensionProperty;
- (void)directExtensionMethod;
@end
```

Annotating an `@implementation` with `objc_direct_members` has a similar effect,
causing non-previously declared members to be deemed direct,
including any implicit methods resulting from property synthesis.

使用 `objc_direct_members` 注释 `@implementation` 也有类似的效果，会将此前所有未声明的成员都变成“直接”的，包括所有 property 的隐式方法。

```objc
__attribute__((objc_direct_members))
@implementation MyClass
- (BOOL)directProperty {<#...#>}
- (void)dynamicMethod {<#...#>}
- (void)directMethod {<#...#>}
- (void)directExtensionMethod {<#...#>}
- (void)directImplementationMethod {<#...#>}
@end
```

{% error %}

A dynamic method can't be overridden in a subclass by a direct method,
and a direct method can't be overridden at all.

动态方法不能被子类的直接方法 override，直接方法更是完全不能被 override。

Protocols can't declare direct method requirements,
and a class can't implement a protocol requirement
with a direct method.

Protocol 不能将方法声明为“直接”的，class 也不能使用直接方法实现 Protocol 的要求。

{% enderror %}

Applying these annotations to our example from before,
we can see how direct and dynamic methods are indistinguishable at the call site:

将这些注释应用到我们之前的例子中，我们可以看到在调用的时候，根本无法区分直接方法和动态方法：

```objc
MyClass *object = [[[MyClass] alloc] init];

// Dynamic Dispatch
// 动态派发
[object dynamicMethod];

// Direct Dispatch
// 直接派发
[object directMethod];
```

---

Direct methods seem like a slam dunk feature
for the performance-minded developers among us.
But here's the twist:

对于我们这些关注性能的开发人员来说，直接方法似乎是一个非常有用的特性。但这里有个转折:

**In most cases,
making a method direct probably won't have a noticeable performance advantage.**

**在大多数情况下，使用直接方法可能并不会带来明显的性能优势。**

As it turns out,
[`objc_msgSend` is surprisingly fast](https://www.mikeash.com/pyblog/friday-qa-2016-04-15-performance-comparisons-of-common-operations-2016-edition.html).
Thanks to aggressive caching, extensive low-level optimization,
and intrinsic performance characteristics of modern processors,
`objc_msgSend` has an extremely low overhead.

事实证明，[`objc_msgSend` 的速度快得惊人](https://www.mikeash.com/pyblog/friday-qa-2016-04-15-performance-comparisons-of-common-operations-2016-edition.html)。由于使用积极的缓存、广泛的底层优化，以及现代处理器固有的性能特征，`objc_msgSend` 的开销非常低。

We're long past the days when iPhone hardware
could reasonably be described as a resource-constrained environment.
So unless Apple is preparing for a new embedded platform
_([AR glasses, anyone?](http://appleinsider.com/articles/17/01/09/rumor-apple-working-with-carl-zeiss-on-ar-glasses-to-debut-in-2018))_,
the most reasonable explanation we have for
Apple implementing Objective-C direct methods in 2019
stems from something other than performance.

iPhone 硬件已经不再是以前那个资源有限的平台。因此，除非苹果正在准备一个新的嵌入式平台（[AR眼镜，有人知道吗？](http://appleinsider.com/articles/17/01/09/rumor-apple-working-with-carl-zeiss-on-ar-glasses-to-debut-in-2018)），我们觉得苹果在 2019 年实现 Objective-C 直接方法的最合理解释，除了性能之外，肯定还有其他原因。

{% info %}

[Mike Ash](https://www.mikeash.com)
is the Internet's foremost expert on `objc_msgSend`.
Over the years,
his posts have provided the deepest and most complete understanding
to the Objective-C runtime you'll find outside of Cupertino.
For the curious,
["Dissecting objc_msgSend on ARM64"](https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html)
is a great place to start.

[Mike Ash](https://www.mikeash.com) 是互联网上最著名的 `objc_msgSend` 专家。多年以来在理解 Objective-C 运行时的方面，他的文章是苹果官方以外最深刻、最完整的。对于那些好奇的人来说，[“剖析 ARM64 上的 objc_msgSend”](https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html) 是一个很好的开始。

{% endinfo %}

## Hidden Motives

## 隐藏的动机

When an Objective-C method is marked as direct,
its implementation has hidden visibility.
That is,
direct methods can only be called within the same module
_(or to be pedantic,
<dfn>[linkage unit](https://clang.llvm.org/docs/LTOVisibility.html)</dfn>)._
It won't even show up in the Objective-C runtime.

Objective-C 方法被标记为“直接”后，它的实现就被隐藏了。也就是说，直接方法只能在相同的模块（_或学术地讲，[链接单元（linkage unit）](https://clang.llvm.org/docs/LTOVisibility.html)_）中调用。它们甚至不会出现在 Objective-C 运行时中。

Hidden visibility has two direct advantages:

隐藏可见性有两个直接的好处：

- Smaller binary size
- No external invocation

- 更小的二进制文件
- 无法被外部调用

Without external visibility
or a way to invoke them dynamically from the Objective-C runtime,
direct methods are effectively private methods.

没有外部可见性，也不能在 Objective-C 运行时中动态调用，直接方法实际上就是私有方法。

{% info %}

If you want to participate in direct dispatch,
but still want to make your API accessible externally,
you can wrap it in a C function.

如果你希望使用直接派发，但仍然希望能在外部访问你的 API，你可以将其封装在一个 C 函数中。

```objc
static inline void performDirectMethod(MyClass *__unsafe_unretained object) {
    [object directMethod];
}
```

{% endinfo %}

While hidden visibility can be used by Apple
to prevent swizzling and private API use,
that doesn't seem to be the primary motivation.

虽然隐藏可见性可以被苹果用来防止 swizzling 和私有 API 的使用，但这似乎不是主要的动机。

[According to Pierre](https://twitter.com/pedantcoder/status/1197269246289444864),
who implemented this feature,
the main benefit of this optimization is code size reduction.
Reportedly,
the weight of unused Objective-C metadata
can account for 5 – 10% of the `__text` section in the compiled binary.

根据实现该特性的 [Pierre 的说法](https://twitter.com/pedantcoder/status/1197269246289444864)，这种优化的主要好处是减少代码大小。据报道，在编译后的二进制文件的 `__text` 区中，5 - 10% 的内容是未使用的 Objective-C 元数据。

---

You could imagine that,
from now until next year's developer conference,
a few engineers could go through each of the SDK frameworks,
annotating private methods with `objc_direct`
and private classes with `objc_direct_members`
as a lightweight way to progressively tighten its SDK.

你可以想象，从现在到明年的开发者大会这段时间，工程师们会遍历每个 SDK framework，使用 `objc_direct` 注释私有方法，使用 `objc_direct_members` 注释私有类，这是一种比较轻便的逐步收紧 SDK 的方法。

If that's true,
then perhaps it's just as well that we've become skeptical of new Objective-C features.
When they're not in service of Swift,
they're in service of Apple.
Despite its important place in the history of programming and Apple itself,
it's hard not to see Objective-C as just that --- _history_.

如果这是真的，也许我们应该开始怀疑 Objective-C 的所有新特性了。因为它们不是为 Swift 服务，就是为苹果服务。尽管 Objective-C 在编程史和苹果公司的发展史上占有重要的地位，但也不得不将它视为 _历史_。
